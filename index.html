<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MBTA Tracker</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    
    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    
    <!-- Polyline decoder for encoded polylines -->
    <script src="https://unpkg.com/polyline@0.2.0/src/polyline.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        
        #map {
            height: 100vh;
            width: 100%;
        }
        
        .info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            z-index: 1000;
            width: 180px;
            max-height: none;
            overflow: hidden;
        }
        
        .info-panel h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 18px;
        }
        
        .info-panel p {
            margin: 8px 0;
            font-size: 14px;
        }
        
        .coordinates {
            font-family: monospace;
            background: #f5f5f5;
            padding: 8px;
            border-radius: 4px;
            margin: 8px 0;
            font-size: 12px;
        }
        
        .filter-controls {
            margin: 8px 0;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        
        .filter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 0 0 10px 0;
        }
        
        .filter-controls h4 {
            margin: 0;
            font-size: 14px;
            color: #555;
        }
        
        .lines-toggle {
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            width: 24px;
            height: 24px;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .lines-toggle:hover {
            background: #0056b3;
        }
        
        .lines-toggle.collapsed {
            transform: rotate(180deg);
        }
        
        .category-filters {
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .category-filters.collapsed {
            max-height: 0;
            opacity: 0;
            margin: 0;
            padding: 0;
        }
        
        .filter-checkbox {
            margin: 4px 0;
            font-size: 13px;
            display: flex;
            align-items: center;
            height: 20px;
        }
        
        .filter-checkbox input {
            margin-right: 8px;
            margin: 0;
        }
        
        .filter-checkbox label {
            margin: 0;
            line-height: 1;
        }
        
        .stats {
            background: #e9ecef;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            font-size: 12px;
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px 6px 10px;
            border-bottom: 1px solid #eee;
            background: #f8f9fa;
            border-radius: 8px 8px 0 0;
        }
        
        .panel-header h3, .panel-header h4 {
            margin: 0;
            color: #333;
        }
        
        .panel-toggle {
            position: absolute;
            right: -30px;
            top: 50%;
            transform: translateY(-50%);
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 0 8px 8px 0;
            width: 30px;
            height: 60px;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 1001;
            box-shadow: 4px 0 10px rgba(0,0,0,0.4);
        }
        
        .panel-toggle:hover {
            background: #0056b3;
            width: 25px;
        }
        
        .panel-content {
            padding: 10px;
            max-height: none;
            overflow-y: visible;
        }
        
        .panel-hidden {
            transform: translateX(-100%);
        }
        
        .panel-hidden .panel-toggle {
            right: -20px;
            background: #666;
        }
        
        .info-panel {
            transition: transform 0.3s ease;
        }
        
        .search-box {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            z-index: 1000;
            width: 250px;
        }
        
        .search-box input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .search-results {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }
        
        .search-result {
            padding: 8px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            font-size: 13px;
        }
        
        .search-result:hover {
            background: #f5f5f5;
        }
        
        /* Custom tooltip styling to look like popups */
        .custom-tooltip.leaflet-tooltip {
            background-color: white;
            border: 2px solid #ccc;
            border-radius: 12px;
            box-shadow: 0 3px 14px rgba(0,0,0,0.4);
            padding: 8px;
            font-family: inherit;
            max-width: 300px;
        }
        
        /* Arrow styling for tooltips - make arrows white based on direction */
        .custom-tooltip.leaflet-tooltip-top::before {
            border-top-color: white !important;  /* Arrow pointing up (tooltip above marker) */
        }
        
        .custom-tooltip.leaflet-tooltip-bottom::before {
            border-bottom-color: white !important;  /* Arrow pointing down (tooltip below marker) */
        }
        
        /* Loading spinner animation */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="info-panel" id="info-panel">
        <button class="panel-toggle" onclick="togglePanel('info-panel')">◀</button>

        
        <div class="panel-content">
            <div class="filter-controls">
                <div class="filter-header">
                    <h4>Show/Hide Lines:</h4>
                    <button class="lines-toggle" onclick="toggleLinesSection()" title="Hide/Show Lines Section">−</button>
                </div>
                
                <!-- Service controls with Paths and Live columns -->
                <div class="category-filters" id="lines-section">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr>
                                <th style="text-align: left; padding: 5px; font-size: 12px;">Service</th>
                                <th style="text-align: center; padding: 5px; font-size: 12px;">Paths</th>
                                <th style="text-align: center; padding: 5px; font-size: 12px;">Live</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td style="padding: 5px; font-size: 12px;">Subway</td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-subway-paths" checked>
                                </td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-subway-live" checked>
                                </td>
                            </tr>
                            <tr>
                                <td style="padding: 5px; font-size: 12px;">Commuter Rail</td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-commuter-paths" checked>
                                </td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-commuter-live" checked>
                                </td>
                            </tr>
                            <tr>
                                <td style="padding: 5px; font-size: 12px;">Seasonal Rail</td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-seasonal-paths" checked>
                                </td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-seasonal-live" checked>
                                </td>
                            </tr>
                            <tr>
                                <td style="padding: 5px; font-size: 12px;">Bus</td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-bus-paths">
                                </td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-bus-live">
                                </td>
                            </tr>
                            <tr>
                                <td style="padding: 5px; font-size: 12px;">Silver Line</td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-silver-line-paths">
                                </td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-silver-line-live">
                                </td>
                            </tr>
                            <tr id="bus-loading-indicator" style="display: none;">
                                <td colspan="3" style="padding: 5px; font-size: 11px; text-align: center; color: #007bff;">
                                    <div style="display: flex; align-items: center; justify-content: center; gap: 5px;">
                                        <div style="width: 12px; height: 12px; border: 2px solid #007bff; border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                                        <span id="bus-loading-text">Loading bus routes...</span>
                                    </div>
                                </td>
                            </tr>
                            <tr>
                                <td style="padding: 5px; font-size: 12px;">Shuttle</td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-shuttle-paths">
                                </td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-shuttle-live">
                                </td>
                            </tr>
                            <tr>
                                <td style="padding: 5px; font-size: 12px;">Ferry</td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-ferry-paths" checked>
                                </td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-ferry-live" checked>
                                </td>
                            </tr>
                            <tr>
                                <td style="padding: 5px; font-size: 12px;">Amtrak</td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-amtrak-paths" checked>
                                </td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-amtrak-live" checked>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
    

    

    


    <!-- Include the MBTA stops data -->
    <script src="mbta-stops-accurate.js"></script>
    
    <!-- Include the MBTA bus data -->
            <script src="mbta-bus-data.js"></script>
    
    <!-- Include the MBTA shuttle data -->
    <script src="mbta-shuttle-data.js"></script>
    
    <!-- Include the MBTA ferry data -->
    <script src="mbta-ferry-data.js"></script>
    
    <!-- Include the Silver Line data -->
    <script src="mbta-silver-line-data.js"></script>

    <script>
        // Global variables - declare these first
        const trainMarkers = new Map();
        const ferryMarkers = new Map();
        const amtrakMarkers = new Map();
        const busMarkers = new Map();
        const shuttleMarkers = new Map();
        const busStopMarkers = new Map(); // Track bus stop markers for zoom control
        const silverLineStopMarkers = new Map(); // Track Silver Line stop markers for zoom control
        let trackingInterval;
        let ferryTrackingInterval;
        let amtrakTrackingInterval;
        let busTrackingInterval;
        let shuttleTrackingInterval;
        let lastUpdateTime = 0;
        let lastFerryUpdateTime = 0;
        let lastAmtrakUpdateTime = 0;
        let lastBusUpdateTime = 0;
        let lastShuttleUpdateTime = 0;
        
        // State for line highlighting feature
        let highlightedLine = null;
        
        // Bus route loading state
        let busRoutesLoaded = false;
        let busRoutesLoading = false;
        
        // Shuttle route loading state
        let shuttleRoutesLoaded = false;
        let shuttleRoutesLoading = false;
        
        // Silver Line loading state
        let silverLineLoaded = false;
        let silverLineLoading = false;
        
        // Bus stop visibility threshold
        const BUS_STOP_MIN_ZOOM = 14;
        
        // Check if data is ready before proceeding
        if (typeof mbtaStopsData === 'undefined' || !mbtaStopsData) {
            document.getElementById('map').innerHTML = '<div style="text-align: center; padding: 50px; font-size: 18px; color: #666;">Loading MBTA data...</div>';
            // Don't run any more code
            throw new Error('MBTA data not loaded');
        }
        
        // Initialize the map centered on Boston with canvas renderer for better performance
        const map = L.map('map', {
            preferCanvas: true,  // Use canvas for better performance with many objects
            renderer: L.canvas()
        }).setView([42.3601, -71.0589], 11);
        
        // Add OpenStreetMap tiles
        const osmTiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            maxZoom: 19
        });
        
        osmTiles.addTo(map);
        
        // Add click handler to map to reset highlight when clicking empty space
        map.on('click', function(e) {
            if (highlightedLine !== null) {
                resetHighlight();
            }
        });
        
        // Add zoom handler to control bus and Silver Line stop visibility
        map.on('zoomend', function() {
            if (busRoutesLoaded) {
                updateBusStopVisibility();
            }
            if (silverLineLoaded) {
                updateSilverLineStopVisibility();
            }
        });
        
        
        // Create layer groups for each transit line
        const layers = {};
        
        // Initialize layers for all lines
        if (mbtaStopsData && typeof mbtaStopsData === 'object') {
            try {
                Object.keys(mbtaStopsData).forEach(lineName => {
                    layers[lineName] = L.layerGroup();
                    // Don't add to map yet - wait for checkbox
                });
            } catch (e) {
                // Silently handle any errors
            }
        }
        
        // Initialize layers for bus routes
        if (mbtaBusData && typeof mbtaBusData === 'object') {
            try {
                Object.keys(mbtaBusData).forEach(lineName => {
                    layers[lineName] = L.layerGroup();
                    // Don't add to map yet - wait for checkbox
                });
            } catch (e) {
                // Silently handle any errors
            }
        }
        
        // Initialize layers for shuttle routes
        if (mbtaShuttleData && typeof mbtaShuttleData === 'object') {
            try {
                Object.keys(mbtaShuttleData).forEach(lineName => {
                    layers[lineName] = L.layerGroup();
                    // Don't add to map yet - wait for checkbox
                });
            } catch (e) {
                // Silently handle any errors
            }
        }
        
        // Initialize layers for Silver Line routes
        if (typeof silverLineData !== 'undefined' && silverLineData && typeof silverLineData === 'object') {
            try {
                Object.keys(silverLineData).forEach(lineName => {
                    layers[lineName] = L.layerGroup();
                    // Don't add to map yet - wait for checkbox
                });
            } catch (e) {
                // Silently handle any errors
            }
        }
        
        // Initialize layers for ferry routes
        if (mbtaFerryData && typeof mbtaFerryData === 'object') {
            try {
                Object.keys(mbtaFerryData).forEach(lineName => {
                    layers[lineName] = L.layerGroup();
                    map.addLayer(layers[lineName]);
                });
            } catch (e) {
                // Silently handle any errors
            }
        }
        
        // Generate filter checkboxes dynamically
        const filterContainer = document.getElementById('filter-checkboxes');
        
        // Define subway, commuter rail, seasonal rail, and bus lines
        const subwayLines = ['Red Line', 'Orange Line', 'Blue Line', 'Green Line B', 'Green Line C', 'Green Line D', 'Green Line E', 'Mattapan Trolley'];
        const commuterLines = ['Fairmount Line', 'Fall River/New Bedford Line', 'Fitchburg Line', 'Framingham/Worcester Line', 'Franklin/Foxboro Line', 'Greenbush Line', 'Haverhill Line', 'Kingston Line', 'Lowell Line', 'Needham Line', 'Newburyport/Rockport Line', 'Providence/Stoughton Line', 'Foxboro Event Service'];
        const seasonalLines = ['CapeFLYER'];
        const busLines = ['1', '4', '7', '8', '9', '10', '11', '14', '15', '16', '17', '18', '19', '21', '22', '23', '24', '26', '28', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '40', '41', '42', '43', '44', '45', '47', '50', '51', '52', '55', '57', '59', '60', '61', '62', '64', '65', '66', '67', '68', '69', '70', '71', '73', '74', '75', '76', '77', '78', '80', '83', '85', '86', '87', '88', '89', '90', '91', '92', '93', '94', '95', '96', '97', '99', '100', '101', '104', '105', '106', '108', '109', '110', '111', '112', '114', '116', '119', '120', '121', '131', '132', '134', '137', '171', '201', '202', '210', '211', '215', '216', '217', '220', '222', '225', '226', '230', '236', '238', '240', '245', '350', '351', '411', '424', '428', '430', '435', '436', '439', '441', '442', '450', '451', '455', '456', '501', '504', '505', '553', '554', '556', '558', '627', '708', '712', '713', '714', '716', '741', '742', '743', '746', '747', '749', '751'];
        const ferryLines = ['Boat-F4', 'Boat-F1', 'Boat-EastBoston', 'Boat-Lynn', 'Boat-F6', 'Boat-F7', 'Boat-F8'];
        const amtrakLines = ['Amtrak']; // Will be populated with actual route names from API

        
        // Add event listeners for category filters
        // Subway paths filter
        document.getElementById('show-subway-paths').addEventListener('change', function() {
            const isChecked = this.checked;
            subwayLines.forEach(lineName => {
                if (mbtaStopsData[lineName] && layers[lineName]) {
                    if (isChecked) {
                        map.addLayer(layers[lineName]);
                    } else {
                        map.removeLayer(layers[lineName]);
                    }
                }
            });
            updateStats();
        });
        
        // Subway live tracking filter
        document.getElementById('show-subway-live').addEventListener('change', function() {
            const isChecked = this.checked;
            
            // Hide/show train markers for subway lines ONLY
            trainMarkers.forEach((marker, trainId) => {
                if (marker && marker.routeName) {
                    if (subwayLines.includes(marker.routeName)) {
                        if (isChecked) {
                            marker.addTo(map);
                        } else {
                            marker.remove();
                        }
                    }
                }
            });
            
            // Control live tracking for subway lines
            if (isChecked) {
                // Resume live tracking if it was stopped
                if (!trackingInterval) {
                    startLiveTracking();
                }
            } else {
                // Check if any other services are still active for live tracking
                const hasCommuter = document.getElementById('show-commuter-live').checked;
                const hasSeasonal = document.getElementById('show-seasonal-live').checked;
                const hasBus = document.getElementById('show-bus-live').checked;
                const hasFerry = document.getElementById('show-ferry-live').checked;
                const hasAmtrak = document.getElementById('show-amtrak-live').checked;
                
                // If no categories are checked, stop live tracking
                if (!hasCommuter && !hasSeasonal && !hasBus && !hasFerry && !hasAmtrak) {
                    stopLiveTracking();
                }
            }
            
            updateStats();
        });
        
        // Commuter rail paths filter
        document.getElementById('show-commuter-paths').addEventListener('change', function() {
            const isChecked = this.checked;
            commuterLines.forEach(lineName => {
                if (mbtaStopsData[lineName] && layers[lineName]) {
                    if (isChecked) {
                        map.addLayer(layers[lineName]);
                    } else {
                        map.removeLayer(layers[lineName]);
                    }
                }
            });
            updateStats();
        });
        
        // Commuter rail live tracking filter
        document.getElementById('show-commuter-live').addEventListener('change', function() {
            const isChecked = this.checked;
            
            // Hide/show train markers for commuter rail lines ONLY
            trainMarkers.forEach((marker, trainId) => {
                if (marker && marker.routeName) {
                    if (commuterLines.includes(marker.routeName) || (marker.routeId && marker.routeId.startsWith('CR-'))) {
                        if (isChecked) {
                            marker.addTo(map);
                        } else {
                            marker.remove();
                        }
                    }
                }
            });
            
            // Control live tracking for commuter rail lines
            if (isChecked) {
                // Resume live tracking if it was stopped
                if (!trackingInterval) {
                    startLiveTracking();
                }
            } else {
                // Check if any other services are still active for live tracking
                const hasSubway = document.getElementById('show-subway-live').checked;
                const hasSeasonal = document.getElementById('show-seasonal-live').checked;
                const hasBus = document.getElementById('show-bus-live').checked;
                const hasFerry = document.getElementById('show-ferry-live').checked;
                const hasAmtrak = document.getElementById('show-amtrak-live').checked;
                
                // If no categories are checked, stop live tracking
                if (!hasSubway && !hasSeasonal && !hasBus && !hasFerry && !hasAmtrak) {
                    stopLiveTracking();
                }
            }
            
            updateStats();
        });
        
        // Seasonal rail paths filter
        document.getElementById('show-seasonal-paths').addEventListener('change', function() {
            const isChecked = this.checked;
            seasonalLines.forEach(lineName => {
                if (mbtaStopsData[lineName] && layers[lineName]) {
                    if (isChecked) {
                        map.addLayer(layers[lineName]);
                    } else {
                        map.removeLayer(layers[lineName]);
                    }
                }
            });
            updateStats();
        });
        
        // Seasonal rail live tracking filter
        document.getElementById('show-seasonal-live').addEventListener('change', function() {
            const isChecked = this.checked;
            
            // Hide/show train markers for seasonal rail lines ONLY
            trainMarkers.forEach((marker, trainId) => {
                if (marker && marker.routeName) {
                    if (seasonalLines.includes(marker.routeName)) {
                        if (isChecked) {
                            marker.addTo(map);
                        } else {
                            marker.remove();
                        }
                    }
                }
            });
            
            // Control live tracking for seasonal rail lines
            if (isChecked) {
                // Resume live tracking if it was stopped
                if (!trackingInterval) {
                    startLiveTracking();
                }
            } else {
                // Check if any other services are still active for live tracking
                const hasSubway = document.getElementById('show-subway-live').checked;
                const hasCommuter = document.getElementById('show-commuter-live').checked;
                const hasBus = document.getElementById('show-bus-live').checked;
                const hasFerry = document.getElementById('show-ferry-live').checked;
                const hasAmtrak = document.getElementById('show-amtrak-live').checked;
                
                // If no categories are checked, stop live tracking
                if (!hasSubway && !hasCommuter && !hasBus && !hasFerry && !hasAmtrak) {
                    stopLiveTracking();
                }
            }
            
            updateStats();
        });
        
        // Bus paths filter - OPTIMIZED
        document.getElementById('show-bus-paths').addEventListener('change', function() {
            const isChecked = this.checked;
            
            if (mbtaBusData && typeof mbtaBusData === 'object') {
                if (isChecked) {
                    // Load bus routes progressively when checkbox is enabled
                    loadBusRoutesChunked(true);
                } else {
                    // Hide all bus route layers
                    Object.keys(mbtaBusData).forEach(lineName => {
                        if (mbtaStopsData && mbtaStopsData[lineName]) return;
                        if (layers[lineName]) {
                            map.removeLayer(layers[lineName]);
                        }
                    });
                    
                    // Hide loading indicator if it's showing
                    const loadingIndicator = document.getElementById('bus-loading-indicator');
                    if (loadingIndicator) {
                        loadingIndicator.style.display = 'none';
                    }
                }
            }
            updateStats();
        });
        
        // Bus live tracking filter
        document.getElementById('show-bus-live').addEventListener('change', function() {
            const isChecked = this.checked;
            
            // Hide/show bus markers (but not Silver Line - they have their own checkbox)
            const silverLineRoutes = ['741', '742', '743', '749', '751', '746'];
            busMarkers.forEach((marker, busId) => {
                if (marker) {
                    // Skip Silver Line vehicles - they have their own checkbox
                    if (marker.apiRouteId && silverLineRoutes.includes(marker.apiRouteId)) {
                        return;
                    }
                    
                    if (isChecked) {
                        marker.addTo(map);
                    } else {
                        marker.remove();
                    }
                }
            });
            
            // Control live tracking for bus routes
            if (isChecked) {
                // Resume live tracking if it was stopped
                if (!trackingInterval) {
                    startLiveTracking();
                }
            } else {
                // Check if any other services are still active for live tracking
                const hasSubway = document.getElementById('show-subway-live').checked;
                const hasCommuter = document.getElementById('show-commuter-live').checked;
                const hasSeasonal = document.getElementById('show-seasonal-live').checked;
                const hasShuttle = document.getElementById('show-shuttle-live').checked;
                const hasFerry = document.getElementById('show-ferry-live').checked;
                const hasAmtrak = document.getElementById('show-amtrak-live').checked;
                
                // If no categories are checked, stop live tracking
                if (!hasSubway && !hasCommuter && !hasSeasonal && !hasShuttle && !hasFerry && !hasAmtrak) {
                    stopLiveTracking();
                }
            }
            
            updateStats();
        });
        
        // Shuttle paths filter
        document.getElementById('show-shuttle-paths').addEventListener('change', function() {
            const isChecked = this.checked;
            
            if (mbtaShuttleData && typeof mbtaShuttleData === 'object') {
                if (isChecked) {
                    // Load shuttle routes when checkbox is enabled
                    loadShuttleRoutesChunked(true);
                } else {
                    // Hide all shuttle route layers
                    Object.keys(mbtaShuttleData).forEach(lineName => {
                        if (layers[lineName]) {
                            map.removeLayer(layers[lineName]);
                        }
                    });
                }
            }
            updateStats();
        });
        
        // Shuttle live tracking filter
        document.getElementById('show-shuttle-live').addEventListener('change', function() {
            const isChecked = this.checked;
            
            // Hide/show shuttle markers
            shuttleMarkers.forEach((marker, shuttleId) => {
                if (marker) {
                    if (isChecked) {
                        marker.addTo(map);
                    } else {
                        marker.remove();
                    }
                }
            });
            
            // Control live tracking for shuttles
            if (isChecked) {
                // Resume live tracking if it was stopped
                if (!trackingInterval) {
                    startLiveTracking();
                }
            } else {
                // Check if any other services are still active for live tracking
                const hasSubway = document.getElementById('show-subway-live').checked;
                const hasCommuter = document.getElementById('show-commuter-live').checked;
                const hasSeasonal = document.getElementById('show-seasonal-live').checked;
                const hasBus = document.getElementById('show-bus-live').checked;
                const hasFerry = document.getElementById('show-ferry-live').checked;
                const hasAmtrak = document.getElementById('show-amtrak-live').checked;
                
                // If no categories are checked, stop live tracking
                if (!hasSubway && !hasCommuter && !hasSeasonal && !hasBus && !hasFerry && !hasAmtrak) {
                    stopLiveTracking();
                }
            }
            
            updateStats();
        });
        
        // Silver Line paths filter
        document.getElementById('show-silver-line-paths').addEventListener('change', function() {
            const isChecked = this.checked;
            
            if (typeof silverLineData !== 'undefined' && silverLineData && typeof silverLineData === 'object') {
                if (isChecked) {
                    // Load Silver Line routes when checkbox is enabled
                    loadSilverLine(true);
                } else {
                    // Hide all Silver Line route layers
                    Object.keys(silverLineData).forEach(lineName => {
                        if (layers[lineName]) {
                            map.removeLayer(layers[lineName]);
                        }
                    });
                }
            }
            updateStats();
        });
        
        // Silver Line live tracking filter
        document.getElementById('show-silver-line-live').addEventListener('change', function() {
            const isChecked = this.checked;
            
            // Show/hide Silver Line vehicle markers
            // Silver Line vehicles are in busMarkers but need separate filtering
            const silverLineRoutes = ['741', '742', '743', '749', '751', '746'];
            busMarkers.forEach((marker, vehicleId) => {
                // Check if this marker is a Silver Line vehicle using API route ID
                if (marker && marker.apiRouteId && silverLineRoutes.includes(marker.apiRouteId)) {
                    if (isChecked) {
                        marker.addTo(map);
                    } else {
                        marker.remove();
                    }
                }
            });
            
            // Control live tracking
            if (isChecked) {
                // Resume live tracking if it was stopped
                if (!trackingInterval) {
                    startLiveTracking();
                }
            } else {
                // Check if any other services are still active for live tracking
                const hasSubway = document.getElementById('show-subway-live').checked;
                const hasCommuter = document.getElementById('show-commuter-live').checked;
                const hasSeasonal = document.getElementById('show-seasonal-live').checked;
                const hasBus = document.getElementById('show-bus-live').checked;
                const hasShuttle = document.getElementById('show-shuttle-live').checked;
                const hasFerry = document.getElementById('show-ferry-live').checked;
                const hasAmtrak = document.getElementById('show-amtrak-live').checked;
                
                // If no categories are checked, stop live tracking
                if (!hasSubway && !hasCommuter && !hasSeasonal && !hasBus && !hasShuttle && !hasFerry && !hasAmtrak) {
                    stopLiveTracking();
                }
            }
            
            updateStats();
        });
        
        // Ferry paths filter
        document.getElementById('show-ferry-paths').addEventListener('change', function() {
            const isChecked = this.checked;
            ferryLines.forEach(lineName => {
                if (mbtaFerryData[lineName] && layers[lineName]) {
                    if (isChecked) {
                        map.addLayer(layers[lineName]);
                    } else {
                        map.removeLayer(layers[lineName]);
                    }
                }
            });
            updateStats();
        });
        
        // Ferry live tracking filter
        document.getElementById('show-ferry-live').addEventListener('change', function() {
            const isChecked = this.checked;
            
            // Hide/show ferry markers
            ferryMarkers.forEach((marker, ferryId) => {
                if (marker) {
                    if (isChecked) {
                        marker.addTo(map);
                    } else {
                        marker.remove();
                    }
                }
            });
            
            // Control live tracking for ferry routes
            if (isChecked) {
                // Resume live tracking if it was stopped
                if (!trackingInterval) {
                    startLiveTracking();
                }
            } else {
                // Check if any other services are still active for live tracking
                const hasSubway = document.getElementById('show-subway-live').checked;
                const hasCommuter = document.getElementById('show-commuter-live').checked;
                const hasSeasonal = document.getElementById('show-seasonal-live').checked;
                const hasBus = document.getElementById('show-bus-live').checked;
                const hasAmtrak = document.getElementById('show-amtrak-live').checked;
                
                // If no categories are checked, stop live tracking
                if (!hasSubway && !hasCommuter && !hasSeasonal && !hasBus && !hasAmtrak) {
                    stopLiveTracking();
                }
            }
            
            updateStats();
        });
        
        // Amtrak paths filter
        document.getElementById('show-amtrak-paths').addEventListener('change', function() {
            const isChecked = this.checked;
            
            if (isChecked) {
                // Load Amtrak routes if not already loaded
                if (!window.amtrakRoutesLoaded) {
                    loadAmtrakRoutes();
                }
                
                // Load Amtrak stations
                loadAmtrakStations();
                
                // Show Amtrak route layer group if it exists
                if (window.amtrakRouteLayerGroup) {
                    window.amtrakRouteLayerGroup.addTo(map);
                }
                
                // Also show individual route layers (for API-loaded routes)
                if (window.amtrakRouteLayers) {
                    Object.values(window.amtrakRouteLayers).forEach(layer => {
                        if (layer && !map.hasLayer(layer)) {
                            map.addLayer(layer);
                        }
                    });
                }
                
                // Show Amtrak station markers
                if (window.amtrakStationMarkers) {
                    window.amtrakStationMarkers.forEach(marker => {
                        if (marker) marker.addTo(map);
                    });
                }
            } else {
                // Hide Amtrak routes - remove the layer group if it exists
                if (window.amtrakRouteLayerGroup) {
                    map.removeLayer(window.amtrakRouteLayerGroup);
                }
                
                // Also remove individual route layers (for API-loaded routes)
                if (window.amtrakRouteLayers) {
                    Object.values(window.amtrakRouteLayers).forEach(layer => {
                        if (layer && map.hasLayer(layer)) {
                            map.removeLayer(layer);
                        }
                    });
                }
                
                // Hide Amtrak station markers
                if (window.amtrakStationMarkers) {
                    window.amtrakStationMarkers.forEach(marker => {
                        if (marker) marker.remove();
                    });
                }
            }
            
            updateStats();
        });
        
        // Amtrak live tracking filter
        document.getElementById('show-amtrak-live').addEventListener('change', function() {
            const isChecked = this.checked;
            
            // Hide/show existing Amtrak train markers
            if (amtrakMarkers) {
                amtrakMarkers.forEach(marker => {
                    if (marker) {
                        if (isChecked) {
                            marker.addTo(map);
                        } else {
                            marker.remove();
                        }
                    }
                });
            }
            
            // Control live tracking for Amtrak
            if (isChecked) {
                // Resume live tracking if it was stopped
                if (!trackingInterval) {
                    startLiveTracking();
                }
            } else {
                // Check if any other services are still active for live tracking
                const hasSubway = document.getElementById('show-subway-live').checked;
                const hasCommuter = document.getElementById('show-commuter-live').checked;
                const hasSeasonal = document.getElementById('show-seasonal-live').checked;
                const hasBus = document.getElementById('show-bus-live').checked;
                const hasFerry = document.getElementById('show-ferry-live').checked;
                
                // If no categories are checked, stop live tracking
                if (!hasSubway && !hasCommuter && !hasSeasonal && !hasBus && !hasFerry) {
                    stopLiveTracking();
                }
            }
            
            updateStats();
        });
        // Color scheme for different lines
        const lineColors = {
            'Red Line': '#DA291C',
            'Orange Line': '#FF6600',
            'Blue Line': '#003DA5',
            'Green Line B': '#00843D',
            'Green Line C': '#00843D',
            'Green Line D': '#00843D',
            'Green Line E': '#00843D',
            'Mattapan Trolley': '#DA291C',
            'Fairmount Line': '#800080',
            'Fall River/New Bedford Line': '#800080',
            'Fitchburg Line': '#800080',
            'Foxboro Event Service': '#800080',
            'Framingham/Worcester Line': '#800080',
            'Franklin/Foxboro Line': '#800080',
            'Greenbush Line': '#800080',
            'Haverhill Line': '#800080',
            'Kingston Line': '#800080',
            'Lowell Line': '#800080',
            'Needham Line': '#800080',
            'Newburyport/Rockport Line': '#800080',
            'Providence/Stoughton Line': '#800080',
            // Bus routes - all yellow
            '71': '#FFD700',
            '73': '#FFD700',
            // Silver Line - silver/gray (official MBTA color)
            'SL1': '#7C878E',
            'SL2': '#7C878E',
            'SL3': '#7C878E',
            'SL4': '#7C878E',
            'SL5': '#7C878E',
            'SLW': '#7C878E',
            // Ferry routes - all blue
            'Boat-F4': '#008EAA',
            'Boat-F1': '#008EAA',
            'Boat-EastBoston': '#008EAA',
            'Boat-Lynn': '#008EAA',
            'Boat-F6': '#008EAA',
            'Boat-F7': '#008EAA',
            'Boat-F8': '#008EAA',
            // Amtrak routes - use distinct colors
            'Amtrak': '#1E3A8A',
            'Northeast Corridor': '#DC2626',
            'Acela': '#7C2D12',
            'Vermonter': '#059669',
            'Downeaster': '#7C3AED',
            'Lake Shore Limited': '#EA580C',
            'Empire Service': '#BE185D'
        };

        
                    // Create markers and tracks for all routes
            const markers = [];
            const stopMarkers = new Map(); // Track markers by stopId for multi-line stops
            
            if (typeof mbtaStopsData !== 'undefined' && typeof routeShapes !== 'undefined') {
                
                let totalTracksDrawn = 0;
                let totalStopsDrawn = 0;
                
                // Batch processing for better performance
                const processRoute = (lineName, stops, color) => {
                    const routeMarkers = [];
                    const routeTracks = [];
                    
                    // Process track shapes
                    if (routeShapes[lineName] && routeShapes[lineName].length > 0) {
                        routeShapes[lineName].forEach((shape, shapeIndex) => {
                            if (shape.coords && shape.coords.length > 1) {
                                // Optimized duplicate coordinate removal
                                const cleanCoords = [];
                                let prevLat = null, prevLon = null;
                                
                                for (let i = 0; i < shape.coords.length; i++) {
                                    const coord = shape.coords[i];
                                    if (prevLat !== coord[0] || prevLon !== coord[1]) {
                                        cleanCoords.push(coord);
                                        prevLat = coord[0];
                                        prevLon = coord[1];
                                    }
                                }
                                
                                if (cleanCoords.length > 1) {
                                    const trackLine = L.polyline(cleanCoords, {
                                        color: color,
                                        weight: 3,
                                        opacity: 0.7
                                    });
                                    
                                    trackLine.bindPopup(`<b>${lineName}</b> Shape ${shapeIndex + 1} Track`);
                                    routeTracks.push(trackLine);
                                    totalTracksDrawn++;
                                }
                            }
                        });
                    }
                    
                    // Process stop markers
                    stops.forEach(stop => {
                        const stopRoutes = stopToRoutes[stop.stopId] || [];
                        const isMultiLine = stopRoutes.length > 1;
                        
                        if (isMultiLine && stopMarkers.has(stop.stopId)) {
                            const existingMarker = stopMarkers.get(stop.stopId);
                            existingMarker.options.colors = existingMarker.options.colors || [];
                            existingMarker.options.colors.push(color);
                            
                            const allLines = stopRoutes.join(', ');
                            existingMarker.bindPopup(`
                                <b>${stop.name}</b><br>
                                Type: ${stop.type}<br>
                                Lines: ${allLines}<br>
                                Coordinates: ${stop.coords[0].toFixed(6)}, ${stop.coords[1].toFixed(6)}
                            `);
                        } else {
                            // Set radius based on stop type
                            let radius;
                            if (stop.type === 'Bus' || stop.type === 'Shuttle') {
                                radius = 5; // Bus/shuttle stops
                            } else {
                                radius = 7; // Subway/rail stops - all same size
                            }
                            
                            const marker = L.circleMarker(stop.coords, {
                                radius: radius,
                                fillColor: color,
                                color: '#fff',
                                weight: 2,
                                opacity: 1,
                                fillOpacity: 0.8,
                                colors: isMultiLine ? [color] : undefined,
                                // Increase the interactive area for easier clicking
                                interactive: true,
                                bubblingMouseEvents: false
                            });
                            
                            // Create a larger invisible hit area for easier clicking
                            const hitRadius = 15; // Larger click radius
                            marker.on('add', function() {
                                const element = marker.getElement();
                                if (element) {
                                    // Increase the pointer-events area
                                    element.style.pointerEvents = 'auto';
                                    element.style.cursor = 'pointer';
                                    // Add padding to make click area larger
                                    const currentRadius = parseFloat(element.getAttribute('r') || '6');
                                    element.setAttribute('data-original-radius', currentRadius);
                                    // Create larger invisible circle for clicking
                                    const parent = element.parentElement;
                                    if (parent) {
                                        const hitCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                                        hitCircle.setAttribute('cx', element.getAttribute('cx'));
                                        hitCircle.setAttribute('cy', element.getAttribute('cy'));
                                        hitCircle.setAttribute('r', hitRadius);
                                        hitCircle.setAttribute('fill', 'transparent');
                                        hitCircle.setAttribute('stroke', 'none');
                                        hitCircle.style.pointerEvents = 'auto';
                                        hitCircle.style.cursor = 'pointer';
                                        parent.insertBefore(hitCircle, element);
                                    }
                                }
                            });
                            
                            const popupText = isMultiLine ? 
                                `<div style="font-size: 11px; line-height: 1.3; margin: 0; padding: 0;"><b>${stop.name}</b><br>Type: ${stop.type}<br>Lines: ${stopRoutes.join(', ')}<br>Coordinates: ${stop.coords[0].toFixed(6)}, ${stop.coords[1].toFixed(6)}</div>` :
                                `<div style="font-size: 11px; line-height: 1.3; margin: 0; padding: 0;"><b>${stop.name}</b><br>Type: ${stop.type}<br>Line: ${lineName}<br>Coordinates: ${stop.coords[0].toFixed(6)}, ${stop.coords[1].toFixed(6)}</div>`;
                            
                            // Use tooltip for all stops, direction based on latitude
                            const tooltipDirection = stop.coords[0] < 42.361220 ? 'bottom' : 'top';
                            marker.bindTooltip(popupText, { 
                                direction: tooltipDirection,
                                permanent: false,
                                interactive: true,
                                className: 'custom-tooltip'
                            });
                            
                            // Add click handler for all subway and commuter rail stops
                            if (stop.type === 'Subway' || stop.type === 'Commuter Rail') {
                                marker.on('click', function(e) {
                                    // Prevent map click from firing
                                    L.DomEvent.stopPropagation(e);
                                    
                                    // Get all routes serving this stop
                                    const servingRoutes = stopToRoutes && stop.stopId ? stopToRoutes[stop.stopId] : [lineName];
                                    
                                    // Check if these routes are already highlighted
                                    const alreadyHighlighted = Array.isArray(highlightedLine) 
                                        ? JSON.stringify(highlightedLine.sort()) === JSON.stringify(servingRoutes.sort())
                                        : highlightedLine === lineName && servingRoutes.length === 1;
                                    
                                    // If clicking the same stop/routes, reset; otherwise highlight
                                    if (alreadyHighlighted) {
                                        resetHighlight();
                                    } else {
                                        highlightMultipleLines(servingRoutes);
                                    }
                                });
                            }
                            
                            routeMarkers.push(marker);
                            totalStopsDrawn++;
                            
                            if (isMultiLine) {
                                stopMarkers.set(stop.stopId, marker);
                            }
                        }
                    });
                    
                    return { markers: routeMarkers, tracks: routeTracks };
                };
                
                // Process routes in chunks to prevent UI freezing
                const routes = Object.entries(mbtaStopsData);
                const chunkSize = 5; // Process 5 routes at a time
                
                const processChunk = (startIndex) => {
                    const endIndex = Math.min(startIndex + chunkSize, routes.length);
                    const chunk = routes.slice(startIndex, endIndex);
                    
                    chunk.forEach(([lineName, stops]) => {
                        const color = lineColors[lineName] || '#666';
                        const result = processRoute(lineName, stops, color);
                        
                        // Batch add markers and tracks to layers
                        result.markers.forEach(marker => {
                            markers.push(marker);
                            layers[lineName].addLayer(marker);
                        });
                        
                        result.tracks.forEach(track => {
                            markers.push(track);
                            layers[lineName].addLayer(track);
                        });
                    });
                    
                    // Process next chunk if there are more routes
                    if (endIndex < routes.length) {
                        setTimeout(() => processChunk(endIndex), 10); // 10ms delay between chunks
                    } else {
        
                    }
                };
                
                // Start processing
                processChunk(0);
                
            } else {
                console.error('Cannot create markers: mbtaStopsData or routeShapes is undefined');
            }
            
            // Create bus route markers and tracks - OPTIMIZED WITH CHUNKED LOADING
            // Don't load all bus routes at once - only initialize layers
            if (mbtaBusData) {
                // Just initialize empty layer groups for now
                Object.keys(mbtaBusData).forEach(lineName => {
                    if (mbtaStopsData && mbtaStopsData[lineName]) {
                        return; // Skip subway/commuter rail
                    }
                    layers[lineName] = L.layerGroup();
                });
            }
            
            // Create ferry route markers and tracks
            if (mbtaFerryData && ferryRouteShapes) {
                Object.keys(mbtaFerryData).forEach(lineName => {
                    const stops = mbtaFerryData[lineName];
                    const color = '#008EAA'; // Ferry blue color
                    const routeMarkers = [];
                    const routeTracks = [];
                    
                    // Process ferry route shapes
                    if (ferryRouteShapes[lineName] && ferryRouteShapes[lineName].length > 0) {
                        ferryRouteShapes[lineName].forEach((shape, shapeIndex) => {
                            if (shape.coords && shape.coords.length > 1) {
                                const trackLine = L.polyline(shape.coords, {
                                    color: color,
                                    weight: 3,
                                    opacity: 0.8
                                });
                                
                                trackLine.bindPopup(`<b>Ferry Route ${lineName}</b> Shape ${shapeIndex + 1}`);
                                routeTracks.push(trackLine);
                            }
                        });
                    }
                    
                    // Process ferry stop markers
                    stops.forEach(stop => {
                        const marker = L.circleMarker(stop.coords, {
                            radius: 6,
                            fillColor: color,
                            color: '#fff',
                            weight: 2,
                            opacity: 1,
                            fillOpacity: 0.9
                        });
                        
                        // Use tooltip for all stops, direction based on latitude
                        const stopContent = `
                            <div style="font-size: 11px; line-height: 1.3; margin: 0; padding: 0;">
                                <b>${stop.name}</b><br>
                                Type: ${stop.type}<br>
                                Route: ${lineName}<br>
                                Coordinates: ${stop.coords[0].toFixed(6)}, ${stop.coords[1].toFixed(6)}
                            </div>
                        `;
                        const tooltipDirection = stop.coords[0] < 42.361220 ? 'bottom' : 'top';
                        marker.bindTooltip(stopContent, { 
                            direction: tooltipDirection,
                            permanent: false,
                            interactive: true,
                            className: 'custom-tooltip'
                        });
                        
                        routeMarkers.push(marker);
                    });
                    
                    // Add markers and tracks to layers
                    routeMarkers.forEach(marker => {
                        layers[lineName].addLayer(marker);
                    });
                    
                    routeTracks.forEach(track => {
                        layers[lineName].addLayer(track);
                    });
                });
            }
        
        // Update stats display (no-op since stats were removed)
        function updateStats() {
            // Stats display was removed - function kept for compatibility
        }
        
        // Function to load bus routes with stops (stops visible only when zoomed in)
        function loadBusRoutesChunked(showOnMap = false) {
            if (busRoutesLoaded || busRoutesLoading) {
                // Already loaded or loading - just show/hide as needed
                if (busRoutesLoaded) {
                    Object.keys(mbtaBusData).forEach(lineName => {
                        if (mbtaStopsData && mbtaStopsData[lineName]) return;
                        if (layers[lineName]) {
                            if (showOnMap) {
                                map.addLayer(layers[lineName]);
                            } else {
                                map.removeLayer(layers[lineName]);
                            }
                        }
                    });
                }
                return;
            }
            
            busRoutesLoading = true;
            const busRoutes = Object.keys(mbtaBusData).filter(lineName => {
                return !mbtaStopsData || !mbtaStopsData[lineName];
            });
            
            console.log(`Loading ${busRoutes.length} bus routes with stops...`);
            
            // Show loading indicator
            const loadingIndicator = document.getElementById('bus-loading-indicator');
            const loadingText = document.getElementById('bus-loading-text');
            if (loadingIndicator) {
                loadingIndicator.style.display = '';
            }
            
            // Process routes in chunks with stops
            const CHUNK_SIZE = 20; // Process 20 routes at a time
            let currentIndex = 0;
            
            const processChunk = () => {
                const endIndex = Math.min(currentIndex + CHUNK_SIZE, busRoutes.length);
                
                for (let i = currentIndex; i < endIndex; i++) {
                    const lineName = busRoutes[i];
                    const stops = mbtaBusData[lineName];
                    const color = lineColors[lineName] || '#FFD700';
                    
                    // Render route shapes if available
                    if (typeof busRouteShapes !== 'undefined' && busRouteShapes[lineName] && busRouteShapes[lineName].length > 0) {
                        busRouteShapes[lineName].forEach((shape, shapeIndex) => {
                            let coords = null;
                            
                            // Handle encoded polyline format (from API)
                            if (shape.polyline && typeof polyline !== 'undefined') {
                                coords = polyline.decode(shape.polyline);
                            }
                            // Handle coordinate array format (from GTFS)
                            else if (shape.coords && Array.isArray(shape.coords)) {
                                coords = shape.coords;
                            }
                            
                            if (coords && coords.length > 1) {
                                const trackLine = L.polyline(coords, {
                                    color: color,
                                    weight: 4,
                                    opacity: 1.0
                                });
                                trackLine.bindPopup(`<b>Bus Route ${lineName}</b>`);
                                layers[lineName].addLayer(trackLine);
                            }
                        });
                    }
                    
                    // Add bus stop markers (visible only when zoomed in)
                    if (stops && Array.isArray(stops)) {
                        // Check current zoom to set initial visibility
                        const currentZoom = map.getZoom();
                        const initiallyVisible = currentZoom >= BUS_STOP_MIN_ZOOM;
                        
                        stops.forEach(stop => {
                            // Create unique stop ID for tracking
                            const stopKey = `${lineName}-${stop.name}-${stop.coords[0]}-${stop.coords[1]}`;
                            
                        // Create circle marker for bus stop
                        const marker = L.circleMarker(stop.coords, {
                            radius: 4,
                            fillColor: color,
                            color: '#fff',
                            weight: 1.5,
                            opacity: initiallyVisible ? 1 : 0,
                            fillOpacity: initiallyVisible ? 0.8 : 0,
                            interactive: true,
                            bubblingMouseEvents: false
                        });
                        
                        // Mark as bus stop for efficient checking during highlight
                        marker.isBusStop = true;
                            
                            // Create tooltip content
                            const tooltipContent = `<div style="font-size: 11px; line-height: 1.3; margin: 0; padding: 0;">
                                <b>${stop.name}</b><br>
                                Type: Bus Stop<br>
                                Route: ${lineName}<br>
                                Coordinates: ${stop.coords[0].toFixed(6)}, ${stop.coords[1].toFixed(6)}
                            </div>`;
                            
                            // Use tooltip, direction based on latitude
                            const tooltipDirection = stop.coords[0] < 42.361220 ? 'bottom' : 'top';
                            marker.bindTooltip(tooltipContent, { 
                                direction: tooltipDirection,
                                permanent: false,
                                interactive: true,
                                className: 'custom-tooltip'
                            });
                            
                            // Add click handler to highlight route
                            marker.on('click', function(e) {
                                // Prevent map click from firing
                                L.DomEvent.stopPropagation(e);
                                
                                // Check if this route is already highlighted
                                const alreadyHighlighted = highlightedLine === lineName;
                                
                                // If clicking the same route, reset; otherwise highlight
                                if (alreadyHighlighted) {
                                    resetHighlight();
                                } else {
                                    highlightMultipleLines([lineName]);
                                }
                            });
                            
                            // Add to layer (in same layer as route paths)
                            layers[lineName].addLayer(marker);
                            
                            // Track marker for zoom control
                            if (!busStopMarkers.has(stopKey)) {
                                busStopMarkers.set(stopKey, marker);
                            }
                        });
                    }
                    
                    // Add to map if requested
                    if (showOnMap && layers[lineName]) {
                        layers[lineName].addTo(map);
                    }
                }
                
                currentIndex = endIndex;
                
                // Update progress
                const progress = Math.round((currentIndex / busRoutes.length) * 100);
                
                // Update loading text
                if (loadingText) {
                    loadingText.textContent = `Loading bus routes... ${progress}%`;
                }
                
                // Process next chunk if there are more routes
                if (currentIndex < busRoutes.length) {
                    setTimeout(() => processChunk(), 10); // 10ms delay between chunks
                } else {
                    busRoutesLoaded = true;
                    busRoutesLoading = false;
                    
                    // Hide loading indicator
                    if (loadingIndicator) {
                        loadingIndicator.style.display = 'none';
                    }
                    
                    console.log('Bus routes and stops loaded successfully');
                    
                    // Update bus stop visibility based on current zoom
                    updateBusStopVisibility();
                }
            };
            
            // Start processing
            processChunk();
        }
        
        // Function to update bus stop visibility based on zoom level
        function updateBusStopVisibility() {
            const currentZoom = map.getZoom();
            const shouldShowByZoom = currentZoom >= BUS_STOP_MIN_ZOOM;
            
            busStopMarkers.forEach((marker, stopKey) => {
                // Extract route name from stop key (format: "lineName-stopName-lat-lng")
                const lineName = stopKey.split('-')[0];
                
                // Check if this stop's route is highlighted (dimmed by another highlight)
                const isDimmed = highlightedLine !== null && (
                    Array.isArray(highlightedLine) ? !highlightedLine.includes(lineName) : highlightedLine !== lineName
                );
                
                // Only show if zoom allows AND not dimmed by highlight
                if (shouldShowByZoom && !isDimmed) {
                    marker.setStyle({ opacity: 1, fillOpacity: 0.8 });
                } else {
                    marker.setStyle({ opacity: 0, fillOpacity: 0 });
                }
            });
        }
        
        // Function to load shuttle routes - similar to bus routes
        function loadShuttleRoutesChunked(showOnMap = false) {
            if (shuttleRoutesLoaded || shuttleRoutesLoading) {
                // Already loaded or loading - just show/hide as needed
                if (shuttleRoutesLoaded) {
                    Object.keys(mbtaShuttleData).forEach(lineName => {
                        if (layers[lineName]) {
                            if (showOnMap) {
                                map.addLayer(layers[lineName]);
                            } else {
                                map.removeLayer(layers[lineName]);
                            }
                        }
                    });
                }
                return;
            }
            
            shuttleRoutesLoading = true;
            const shuttleRoutes = Object.keys(mbtaShuttleData);
            
            console.log(`Loading ${shuttleRoutes.length} shuttle routes...`);
            
            // Process routes
            for (let i = 0; i < shuttleRoutes.length; i++) {
                const lineName = shuttleRoutes[i];
                const stops = mbtaShuttleData[lineName];
                const color = lineColors[lineName] || '#FF6B6B'; // Default shuttle red
                
                // Render route shapes if available
                if (typeof shuttleRouteShapes !== 'undefined' && shuttleRouteShapes[lineName] && shuttleRouteShapes[lineName].length > 0) {
                    shuttleRouteShapes[lineName].forEach((shape, shapeIndex) => {
                        let coords = null;
                        
                        // Handle encoded polyline format (from API)
                        if (shape.polyline && typeof polyline !== 'undefined') {
                            coords = polyline.decode(shape.polyline);
                        }
                        // Handle coordinate array format (from GTFS)
                        else if (shape.coords && Array.isArray(shape.coords)) {
                            coords = shape.coords;
                        }
                        
                        if (coords && coords.length > 1) {
                            const trackLine = L.polyline(coords, {
                                color: color,
                                weight: 5,
                                opacity: 1.0
                            });
                            trackLine.bindPopup(`<b>Shuttle ${lineName}</b>`);
                            layers[lineName].addLayer(trackLine);
                        }
                    });
                }
                
                // Add to map if requested
                if (showOnMap && layers[lineName]) {
                    layers[lineName].addTo(map);
                }
            }
            
            shuttleRoutesLoaded = true;
            shuttleRoutesLoading = false;
            
            console.log('Shuttle routes loaded successfully');
        }
        
        // Function to load Silver Line routes with stops (stops visible only when zoomed in)
        function loadSilverLine(showOnMap = false) {
            if (typeof silverLineData === 'undefined') {
                console.log('Silver Line data not loaded');
                return;
            }
            
            if (silverLineLoaded || silverLineLoading) {
                // Already loaded or loading - just show/hide as needed
                if (silverLineLoaded) {
                    Object.keys(silverLineData).forEach(lineName => {
                        if (layers[lineName]) {
                            if (showOnMap) {
                                map.addLayer(layers[lineName]);
                            } else {
                                map.removeLayer(layers[lineName]);
                            }
                        }
                    });
                }
                return;
            }
            
            silverLineLoading = true;
            const silverRoutes = Object.keys(silverLineData);
            
            console.log(`Loading ${silverRoutes.length} Silver Line routes with stops...`);
            
            // Process routes
            const currentZoom = map.getZoom();
            const initiallyVisible = currentZoom >= BUS_STOP_MIN_ZOOM;
            
            for (let i = 0; i < silverRoutes.length; i++) {
                const lineName = silverRoutes[i];
                const stops = silverLineData[lineName];
                const color = lineColors[lineName] || '#7C878E'; // Silver Line color
                
                // Render route shapes if available
                if (typeof silverLineShapes !== 'undefined' && silverLineShapes[lineName] && silverLineShapes[lineName].length > 0) {
                    silverLineShapes[lineName].forEach((shape, shapeIndex) => {
                        let coords = null;
                        
                        // Handle coordinate array format
                        if (shape.coords && Array.isArray(shape.coords)) {
                            coords = shape.coords;
                        }
                        
                        if (coords && coords.length > 1) {
                            const trackLine = L.polyline(coords, {
                                color: color,
                                weight: 4,
                                opacity: 1.0
                            });
                            trackLine.bindPopup(`<b>Silver Line ${lineName}</b>`);
                            layers[lineName].addLayer(trackLine);
                        }
                    });
                }
                
                // Add stop markers (visible only when zoomed in)
                if (stops && Array.isArray(stops)) {
                    stops.forEach(stop => {
                        // Create unique stop ID for tracking
                        const stopKey = `${lineName}-${stop.name}-${stop.coords[0]}-${stop.coords[1]}`;
                        
                        // Create circle marker for Silver Line stop
                        const marker = L.circleMarker(stop.coords, {
                            radius: 5,
                            fillColor: color,
                            color: '#fff',
                            weight: 1.5,
                            opacity: initiallyVisible ? 1 : 0,
                            fillOpacity: initiallyVisible ? 0.8 : 0,
                            interactive: true,
                            bubblingMouseEvents: false
                        });
                        
                        // Mark as Silver Line stop (also a bus stop) for efficient checking
                        marker.isSilverLineStop = true;
                        marker.isBusStop = true;
                        
                        // Create tooltip content
                        const tooltipContent = `<div style="font-size: 11px; line-height: 1.3; margin: 0; padding: 0;">
                            <b>${stop.name}</b><br>
                            Type: Silver Line Stop<br>
                            Route: ${lineName}<br>
                            Coordinates: ${stop.coords[0].toFixed(6)}, ${stop.coords[1].toFixed(6)}
                        </div>`;
                        
                        // Use tooltip, direction based on latitude
                        const tooltipDirection = stop.coords[0] < 42.361220 ? 'bottom' : 'top';
                        marker.bindTooltip(tooltipContent, { 
                            direction: tooltipDirection,
                            permanent: false,
                            interactive: true,
                            className: 'custom-tooltip'
                        });
                        
                        // Add click handler to highlight route
                        marker.on('click', function(e) {
                            // Prevent map click from firing
                            L.DomEvent.stopPropagation(e);
                            
                            // Check if this route is already highlighted
                            const alreadyHighlighted = highlightedLine === lineName;
                            
                            // If clicking the same route, reset; otherwise highlight
                            if (alreadyHighlighted) {
                                resetHighlight();
                            } else {
                                highlightMultipleLines([lineName]);
                            }
                        });
                        
                        // Add to layer (in same layer as route paths)
                        layers[lineName].addLayer(marker);
                        
                        // Track marker for zoom control
                        if (!silverLineStopMarkers.has(stopKey)) {
                            silverLineStopMarkers.set(stopKey, marker);
                        }
                    });
                }
                
                // Add to map if requested
                if (showOnMap && layers[lineName]) {
                    layers[lineName].addTo(map);
                }
            }
            
            silverLineLoaded = true;
            silverLineLoading = false;
            
            console.log('Silver Line routes and stops loaded successfully');
            
            // Update Silver Line stop visibility based on current zoom
            updateSilverLineStopVisibility();
        }
        
        // Function to update Silver Line stop visibility based on zoom level
        function updateSilverLineStopVisibility() {
            const currentZoom = map.getZoom();
            const shouldShowByZoom = currentZoom >= BUS_STOP_MIN_ZOOM;
            
            silverLineStopMarkers.forEach((marker, stopKey) => {
                // Extract route name from stop key (format: "lineName-stopName-lat-lng")
                const lineName = stopKey.split('-')[0];
                
                // Check if this stop's route is highlighted (dimmed by another highlight)
                const isDimmed = highlightedLine !== null && (
                    Array.isArray(highlightedLine) ? !highlightedLine.includes(lineName) : highlightedLine !== lineName
                );
                
                // Only show if zoom allows AND not dimmed by highlight
                if (shouldShowByZoom && !isDimmed) {
                    marker.setStyle({ opacity: 1, fillOpacity: 0.8 });
                } else {
                    marker.setStyle({ opacity: 0, fillOpacity: 0 });
                }
            });
        }
        
        // Helper function to check if a line is currently highlighted
        function isLineHighlighted(lineName) {
            if (!highlightedLine) return false;
            if (Array.isArray(highlightedLine)) {
                return highlightedLine.length === 1 && highlightedLine[0] === lineName;
            }
            return highlightedLine === lineName;
        }
        
        // Function to highlight multiple lines (for multi-line stops)
        function highlightMultipleLines(lineNames) {
            if (!Array.isArray(lineNames) || lineNames.length === 0) return;
            
            // Store as array if multiple, or single string if one
            highlightedLine = lineNames.length === 1 ? lineNames[0] : lineNames;
            
            // Ensure all highlighted line layers are on the map
            lineNames.forEach(lineName => {
                if (layers[lineName] && !map.hasLayer(layers[lineName])) {
                    map.addLayer(layers[lineName]);
                }
            });
            
            // Check if any of the highlighted lines are shuttles
            const highlightingShuttle = lineNames.some(name => 
                typeof mbtaShuttleData !== 'undefined' && mbtaShuttleData[name]
            );
            
            // Iterate through all layers and adjust opacity
            Object.keys(layers).forEach(layerName => {
                // If highlighting a shuttle, don't dim other shuttles
                const isShuttle = typeof mbtaShuttleData !== 'undefined' && mbtaShuttleData[layerName];
                const shouldSkipDim = highlightingShuttle && isShuttle;
                
                const isDimmed = !lineNames.includes(layerName) && !shouldSkipDim;
                
                layers[layerName].eachLayer(layer => {
                    if (layer.setStyle) {
                        // Handle both polylines (tracks) and circle markers (stops)
                        if (layer instanceof L.Polyline) {
                            // It's a track - store original opacity if not already stored
                            if (!layer.options._originalOpacity) {
                                layer.options._originalOpacity = layer.options.opacity || 0.7;
                            }
                            const targetOpacity = isDimmed ? 0 : layer.options._originalOpacity;
                            layer.setStyle({ opacity: targetOpacity });
                        } else if (layer instanceof L.CircleMarker) {
                            // It's a stop marker - store original opacities if not already stored
                            if (!layer.options._originalOpacity) {
                                layer.options._originalOpacity = layer.options.opacity || 1.0;
                                layer.options._originalFillOpacity = layer.options.fillOpacity || 0.8;
                            }
                            
                            // Check if this is a bus stop and if it should be visible based on zoom
                            const isBusStop = layer.isBusStop === true;
                            const currentZoom = map.getZoom();
                            const shouldBeVisibleByZoom = !isBusStop || currentZoom >= BUS_STOP_MIN_ZOOM;
                            
                            let targetOpacity, targetFillOpacity;
                            if (isDimmed || !shouldBeVisibleByZoom) {
                                targetOpacity = 0;
                                targetFillOpacity = 0;
                            } else {
                                targetOpacity = layer.options._originalOpacity;
                                targetFillOpacity = layer.options._originalFillOpacity;
                            }
                            
                            layer.setStyle({ 
                                opacity: targetOpacity,
                                fillOpacity: targetFillOpacity 
                            });
                        }
                    }
                });
            });
            
            // Dim/highlight live train markers (subway and commuter rail)
            trainMarkers.forEach((marker, trainId) => {
                if (marker && marker.routeName) {
                    const isDimmed = !lineNames.includes(marker.routeName);
                    const targetOpacity = isDimmed ? 0 : 1.0;
                    
                    if (marker.setOpacity) {
                        marker.setOpacity(targetOpacity);
                    }
                }
            });
            
            // Dim/highlight Amtrak train markers
            amtrakMarkers.forEach((marker, trainId) => {
                if (marker && marker.routeName) {
                    const isDimmed = !lineNames.includes(marker.routeName);
                    const targetOpacity = isDimmed ? 0 : 1.0;
                    
                    if (marker.setOpacity) {
                        marker.setOpacity(targetOpacity);
                    }
                }
            });
            
            // Dim/highlight live bus markers
            busMarkers.forEach((marker, busId) => {
                if (marker && marker.routeName) {
                    const isDimmed = !lineNames.includes(marker.routeName);
                    const targetOpacity = isDimmed ? 0 : 1.0;
                    
                    if (marker.setOpacity) {
                        marker.setOpacity(targetOpacity);
                    }
                }
            });
            
            // Dim/highlight live shuttle markers
            // If highlighting a shuttle, keep all shuttles visible
            shuttleMarkers.forEach((marker, shuttleId) => {
                if (marker && marker.routeName) {
                    const isDimmed = !lineNames.includes(marker.routeName) && !highlightingShuttle;
                    const targetOpacity = isDimmed ? 0 : 1.0;
                    
                    if (marker.setOpacity) {
                        marker.setOpacity(targetOpacity);
                    }
                }
            });
            
            // Dim/highlight live ferry markers (always dimmed when any line is highlighted)
            ferryMarkers.forEach((marker, ferryId) => {
                if (marker && marker.setOpacity) {
                    marker.setOpacity(0);
                }
            });
            
            // Dim/highlight Amtrak route tracks (from layer group)
            if (window.amtrakRouteLayerGroup) {
                window.amtrakRouteLayerGroup.eachLayer(polyline => {
                    if (polyline && polyline.routeName && polyline.setStyle) {
                        const isDimmed = !lineNames.includes(polyline.routeName);
                        if (!polyline.options._originalOpacity) {
                            polyline.options._originalOpacity = polyline.options.opacity || 0.8;
                        }
                        const targetOpacity = isDimmed ? 0 : polyline.options._originalOpacity;
                        polyline.setStyle({ opacity: targetOpacity });
                    }
                });
            }
            
            // Also handle Amtrak routes loaded from API (stored in amtrakRouteLayers)
            if (window.amtrakRouteLayers) {
                Object.values(window.amtrakRouteLayers).forEach(polyline => {
                    if (polyline && polyline.routeName && polyline.setStyle) {
                        const isDimmed = !lineNames.includes(polyline.routeName);
                        if (!polyline.options._originalOpacity) {
                            polyline.options._originalOpacity = polyline.options.opacity || 0.8;
                        }
                        const targetOpacity = isDimmed ? 0 : polyline.options._originalOpacity;
                        polyline.setStyle({ opacity: targetOpacity });
                    }
                });
            }
            
            // Dim Amtrak station markers (always dimmed when any line is highlighted)
            if (window.amtrakStationMarkers) {
                window.amtrakStationMarkers.forEach((marker, stationId) => {
                    if (marker && marker.setStyle) {
                        if (!marker.options._originalOpacity) {
                            marker.options._originalOpacity = marker.options.opacity || 1.0;
                            marker.options._originalFillOpacity = marker.options.fillOpacity || 1.0;
                        }
                        marker.setStyle({ 
                            opacity: 0,
                            fillOpacity: 0
                        });
                    }
                });
            }
        }
        
        // Function to highlight a specific line and dim all others
        function highlightLine(lineName) {
            // Check if this is an Amtrak route and if Amtrak routes are loaded
            const isAmtrakRoute = !layers[lineName]; // If not in MBTA layers, assume it's Amtrak
            if (isAmtrakRoute) {
                // Check if any Amtrak routes are loaded
                const hasAmtrakRoutes = (window.amtrakRouteLayerGroup && window.amtrakRouteLayerGroup.getLayers().length > 0) ||
                                       (window.amtrakRouteLayers && Object.keys(window.amtrakRouteLayers).length > 0);
                
                if (!hasAmtrakRoutes) {
                    console.log('Cannot highlight Amtrak route - no Amtrak routes loaded. Enable "Amtrak Paths" first.');
                    return; // Don't highlight if no Amtrak routes are loaded
                }
            }
            
            highlightedLine = lineName;
            
            // Ensure the highlighted line layer is on the map
            if (layers[lineName] && !map.hasLayer(layers[lineName])) {
                map.addLayer(layers[lineName]);
            }
            
            // Check if the highlighted line is a shuttle
            const highlightingShuttle = typeof mbtaShuttleData !== 'undefined' && mbtaShuttleData[lineName];
            
            // Iterate through all layers and adjust opacity
            Object.keys(layers).forEach(layerName => {
                // If highlighting a shuttle, don't dim other shuttles
                const isShuttle = typeof mbtaShuttleData !== 'undefined' && mbtaShuttleData[layerName];
                const shouldSkipDim = highlightingShuttle && isShuttle;
                
                const isDimmed = layerName !== lineName && !shouldSkipDim;
                
                layers[layerName].eachLayer(layer => {
                    if (layer.setStyle) {
                        // Handle both polylines (tracks) and circle markers (stops)
                        if (layer instanceof L.Polyline) {
                            // It's a track - store original opacity if not already stored
                            if (!layer.options._originalOpacity) {
                                layer.options._originalOpacity = layer.options.opacity || 0.7;
                            }
                            const targetOpacity = isDimmed ? 0 : layer.options._originalOpacity;
                            layer.setStyle({ opacity: targetOpacity });
                        } else if (layer instanceof L.CircleMarker) {
                            // It's a stop marker - store original opacities if not already stored
                            if (!layer.options._originalOpacity) {
                                layer.options._originalOpacity = layer.options.opacity || 1.0;
                                layer.options._originalFillOpacity = layer.options.fillOpacity || 0.8;
                            }
                            const targetOpacity = isDimmed ? 0 : layer.options._originalOpacity;
                            const targetFillOpacity = isDimmed ? 0 : layer.options._originalFillOpacity;
                            layer.setStyle({ 
                                opacity: targetOpacity,
                                fillOpacity: targetFillOpacity 
                            });
                        }
                    }
                });
            });
            
            // Dim/highlight live train markers (subway and commuter rail)
            trainMarkers.forEach((marker, trainId) => {
                if (marker && marker.routeName) {
                    const isDimmed = marker.routeName !== lineName;
                    const targetOpacity = isDimmed ? 0 : 1.0;
                    
                    if (marker.setOpacity) {
                        marker.setOpacity(targetOpacity);
                    }
                }
            });
            
            // Dim/highlight Amtrak train markers
            amtrakMarkers.forEach((marker, trainId) => {
                if (marker && marker.routeName) {
                    const isDimmed = marker.routeName !== lineName;
                    const targetOpacity = isDimmed ? 0 : 1.0;
                    
                    if (marker.setOpacity) {
                        marker.setOpacity(targetOpacity);
                    }
                }
            });
            
            // Dim/highlight live bus markers
            busMarkers.forEach((marker, busId) => {
                if (marker && marker.routeName) {
                    const isDimmed = marker.routeName !== lineName;
                    const targetOpacity = isDimmed ? 0 : 1.0;
                    
                    if (marker.setOpacity) {
                        marker.setOpacity(targetOpacity);
                    }
                }
            });
            
            // Dim/highlight live shuttle markers
            // If highlighting a shuttle, keep all shuttles visible
            shuttleMarkers.forEach((marker, shuttleId) => {
                if (marker && marker.routeName) {
                    const isDimmed = marker.routeName !== lineName && !highlightingShuttle;
                    const targetOpacity = isDimmed ? 0 : 1.0;
                    
                    if (marker.setOpacity) {
                        marker.setOpacity(targetOpacity);
                    }
                }
            });
            
            // Dim/highlight live ferry markers (always dimmed when any line is highlighted)
            ferryMarkers.forEach((marker, ferryId) => {
                if (marker && marker.setOpacity) {
                    marker.setOpacity(0);
                }
            });
            
            // Dim/highlight Amtrak route tracks (from layer group)
            if (window.amtrakRouteLayerGroup) {
                window.amtrakRouteLayerGroup.eachLayer(polyline => {
                    if (polyline && polyline.setStyle) {
                        // Check if this polyline has a routeName and if it matches
                        const hasRouteName = polyline.routeName;
                        const isDimmed = hasRouteName ? polyline.routeName !== lineName : false;
                        
                        if (!polyline.options._originalOpacity) {
                            polyline.options._originalOpacity = polyline.options.opacity || 0.8;
                        }
                        const targetOpacity = isDimmed ? 0 : polyline.options._originalOpacity;
                        polyline.setStyle({ opacity: targetOpacity });
                    }
                });
            }
            
            // Also handle Amtrak routes loaded from API (stored in amtrakRouteLayers)
            if (window.amtrakRouteLayers) {
                Object.values(window.amtrakRouteLayers).forEach(polyline => {
                    if (polyline && polyline.setStyle) {
                        // Check if this polyline has a routeName and if it matches
                        const hasRouteName = polyline.routeName;
                        const isDimmed = hasRouteName ? polyline.routeName !== lineName : false;
                        
                        if (!polyline.options._originalOpacity) {
                            polyline.options._originalOpacity = polyline.options.opacity || 0.8;
                        }
                        const targetOpacity = isDimmed ? 0 : polyline.options._originalOpacity;
                        polyline.setStyle({ opacity: targetOpacity });
                    }
                });
            }
            
            // Dim Amtrak station markers (always dimmed when any line is highlighted)
            if (window.amtrakStationMarkers) {
                window.amtrakStationMarkers.forEach((marker, stationId) => {
                    if (marker && marker.setStyle) {
                        if (!marker.options._originalOpacity) {
                            marker.options._originalOpacity = marker.options.opacity || 1.0;
                            marker.options._originalFillOpacity = marker.options.fillOpacity || 1.0;
                        }
                        marker.setStyle({ 
                            opacity: 0,
                            fillOpacity: 0
                        });
                    }
                });
            }
        }
        
        // Function to reset all lines to normal opacity
        function resetHighlight() {
            highlightedLine = null;
            
            // Reset all layers to normal opacity
            Object.keys(layers).forEach(layerName => {
                layers[layerName].eachLayer(layer => {
                    if (layer.setStyle) {
                        if (layer instanceof L.Polyline) {
                            // Reset track opacity to original value
                            const originalOpacity = layer.options._originalOpacity || 0.7;
                            layer.setStyle({ opacity: originalOpacity });
                        } else if (layer instanceof L.CircleMarker) {
                            // Check if this is a bus stop and if it should be visible based on zoom
                            const isBusStop = layer.isBusStop === true;
                            const currentZoom = map.getZoom();
                            const shouldBeVisibleByZoom = !isBusStop || currentZoom >= BUS_STOP_MIN_ZOOM;
                            
                            // Reset stop marker opacity to original values, but respect zoom visibility
                            const originalOpacity = layer.options._originalOpacity || 1.0;
                            const originalFillOpacity = layer.options._originalFillOpacity || 0.8;
                            
                            layer.setStyle({ 
                                opacity: shouldBeVisibleByZoom ? originalOpacity : 0,
                                fillOpacity: shouldBeVisibleByZoom ? originalFillOpacity : 0
                            });
                        }
                    }
                });
                
                // Remove layer from map if its checkbox is not checked
                // Check if this is a bus route
                if (typeof mbtaBusData !== 'undefined' && mbtaBusData[layerName]) {
                    if (!document.getElementById('show-bus-paths').checked) {
                        map.removeLayer(layers[layerName]);
                    }
                }
                // Check if this is a shuttle route
                else if (typeof mbtaShuttleData !== 'undefined' && mbtaShuttleData[layerName]) {
                    if (!document.getElementById('show-shuttle-paths').checked) {
                        map.removeLayer(layers[layerName]);
                    }
                }
                // Check if this is a Silver Line route
                else if (typeof silverLineData !== 'undefined' && silverLineData[layerName]) {
                    if (!document.getElementById('show-silver-line-paths').checked) {
                        map.removeLayer(layers[layerName]);
                    }
                }
            });
            
            // Reset live train markers
            trainMarkers.forEach((marker, trainId) => {
                if (marker && marker.setOpacity) {
                    marker.setOpacity(1.0);
                }
            });
            
            // Reset Amtrak train markers
            amtrakMarkers.forEach((marker, trainId) => {
                if (marker && marker.setOpacity) {
                    marker.setOpacity(1.0);
                }
            });
            
            // Reset live bus markers
            busMarkers.forEach((marker, busId) => {
                if (marker && marker.setOpacity) {
                    marker.setOpacity(1.0);
                }
            });
            
            // Reset live shuttle markers
            shuttleMarkers.forEach((marker, shuttleId) => {
                if (marker && marker.setOpacity) {
                    marker.setOpacity(1.0);
                }
            });
            
            // Reset live ferry markers
            ferryMarkers.forEach((marker, ferryId) => {
                if (marker && marker.setOpacity) {
                    marker.setOpacity(1.0);
                }
            });
            
            // Reset Amtrak route tracks (from layer group)
            if (window.amtrakRouteLayerGroup) {
                window.amtrakRouteLayerGroup.eachLayer(polyline => {
                    if (polyline && polyline.setStyle) {
                        const originalOpacity = polyline.options._originalOpacity || 0.8;
                        polyline.setStyle({ opacity: originalOpacity });
                    }
                });
            }
            
            // Also reset Amtrak routes loaded from API
            if (window.amtrakRouteLayers) {
                Object.values(window.amtrakRouteLayers).forEach(polyline => {
                    if (polyline && polyline.setStyle) {
                        const originalOpacity = polyline.options._originalOpacity || 0.8;
                        polyline.setStyle({ opacity: originalOpacity });
                    }
                });
            }
            
            // Reset Amtrak station markers
            if (window.amtrakStationMarkers) {
                window.amtrakStationMarkers.forEach((marker, stationId) => {
                    if (marker && marker.setStyle) {
                        const originalOpacity = marker.options._originalOpacity || 1.0;
                        const originalFillOpacity = marker.options._originalFillOpacity || 1.0;
                        marker.setStyle({ 
                            opacity: originalOpacity,
                            fillOpacity: originalFillOpacity
                        });
                    }
                });
            }
        }

        
        // Add keyboard event listener for Escape key to reset highlighting
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape' || event.key === 'Esc') {
                resetHighlight();
            }
        });

        
        // Filter controls are now generated dynamically above
        

        
        // Panel toggle functionality
        function togglePanel(panelId) {
            const panel = document.getElementById(panelId);
            const toggle = panel.querySelector('.panel-toggle');
            
            if (panel.classList.contains('panel-hidden')) {
                // Show panel
                panel.classList.remove('panel-hidden');
                toggle.textContent = '◀';
            } else {
                // Hide panel
                panel.classList.add('panel-hidden');
                toggle.textContent = '▶';
            }
        }
        
        // Lines section toggle functionality
        function toggleLinesSection() {
            const linesSection = document.getElementById('lines-section');
            const toggle = document.querySelector('.lines-toggle');
            
            if (linesSection.classList.contains('collapsed')) {
                // Show lines section
                linesSection.classList.remove('collapsed');
                toggle.textContent = '−';
                toggle.classList.remove('collapsed');
            } else {
                // Hide lines section
                linesSection.classList.add('collapsed');
                toggle.textContent = '+';
                toggle.classList.add('collapsed');
            }
        }
        
        // Initialize stats
        updateStats();
        
        // Add scale control
        const scaleControl = L.control.scale({
            position: 'bottomleft'
        }).addTo(map);
        

        

        
        // Live MBTA Train Tracking
        

        
        // Function to fetch live train positions
        async function fetchLiveTrains() {
            try {
                const now = Date.now();
                if (now - lastUpdateTime < 5000) { // Rate limit: 5 seconds
                    return;
                }
                
                const response = await fetch('https://api-v3.mbta.com/vehicles?filter[route_type]=0,1,2&include=route');
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                lastUpdateTime = now;
                
                if (data.data && data.data.length > 0) {
                    updateTrainMarkers(data.data);
                }
                
            } catch (error) {
                console.error('Error fetching MBTA trains:', error);
            }
        }
        
        // Function to fetch live bus positions
        async function fetchLiveBuses() {
            try {
                const now = Date.now();
                if (now - lastBusUpdateTime < 5000) { // Rate limit: 5 seconds
                    return;
                }
                
                const response = await fetch('https://api-v3.mbta.com/vehicles?filter[route_type]=3&include=route');
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                lastBusUpdateTime = now;
                
                if (data.data && data.data.length > 0) {
                    updateBusMarkers(data.data);
                }
                
            } catch (error) {
                console.error('Error fetching MBTA buses:', error);
            }
        }
        
        // Function to fetch live ferry positions
        async function fetchLiveFerries() {
            try {
                const now = Date.now();
                if (now - lastUpdateTime < 5000) { // Rate limit: 5 seconds
                    return;
                }
                
                const response = await fetch('https://api-v3.mbta.com/vehicles?filter[route_type]=4&include=route');
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                lastUpdateTime = now;
                
                if (data.data && data.data.length > 0) {
                    updateFerryMarkers(data.data);
                }
                
            } catch (error) {
                console.error('Error fetching MBTA ferries:', error);
            }
        }
        
        // Amtrak V3 API Client for Live Train Tracking
        class AmtrakV3Client {
            constructor(baseUrl = "https://api-v3.amtraker.com", timeout = 20000) {
                this.baseUrl = baseUrl.replace(/\/$/, "");
                this.timeout = timeout;
                this.session = new Map(); // Simple session cache
            }

            // Internal helper for making requests
            async _get(path, params = null) {
                const url = `${this.baseUrl}/${path.replace(/^\//, '')}`;
                const urlWithParams = params ? `${url}?${new URLSearchParams(params)}` : url;
                
                try {
                    const response = await fetch(urlWithParams, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json'
                        },
                        signal: AbortSignal.timeout(this.timeout)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    return await response.json();
                } catch (error) {
                    console.error(`Error fetching ${urlWithParams}:`, error);
                    throw error;
                }
            }

            // Get all active trains
            async getAllTrains() {
                return await this._get("v3/trains");
            }

            // Get specific train by number or trainId
            async getTrain(trainIdOrNum) {
                return await this._get(`v3/trains/${trainIdOrNum}`);
            }

            // Get all station metadata
            async getAllStations() {
                return await this._get("v3/stations");
            }

            // Get specific station metadata
            async getStation(stationId) {
                return await this._get(`v3/stations/${stationId}`);
            }

            // Get feed health status
            async getStaleStatus() {
                return await this._get("v3/stale");
            }

            // Flatten trains response to records
            static trainsDictToRecords(trainsByNum) {
                const rows = [];
                for (const [trainNum, items] of Object.entries(trainsByNum || {})) {
                    for (const tdata of (items || [])) {
                        if (tdata) {
                            rows.push({
                                trainNum: tdata.trainNum || trainNum,
                                trainId: tdata.trainId,
                                routeName: tdata.routeName,
                                state: tdata.trainState || tdata.state,
                                statusMsg: tdata.statusMsg,
                                lat: tdata.lat,
                                lon: tdata.lon,
                                heading: tdata.heading,
                                velocity: tdata.velocity,
                                lastValTS: tdata.lastValTS || tdata.updatedAt,
                                eventCode: tdata.eventCode,
                                origCode: tdata.origCode,
                                destCode: tdata.destCode,
                                stationsLen: Array.isArray(tdata.stations) ? tdata.stations.length : null
                            });
                        }
                    }
                }
                return rows;
            }

            // Flatten stations response to records
            static stationsDictToRecords(stationsById) {
                const out = [];
                for (const [sid, meta] of Object.entries(stationsById || {})) {
                    if (meta) {
                        out.push({
                            stationId: sid,
                            name: meta.name || meta.stationName,
                            city: meta.city,
                            state: meta.state,
                            tz: meta.tz,
                            lat: meta.lat,
                            lon: meta.lon
                        });
                    }
                }
                return out;
            }
        }

        // Global Amtrak client instance
        let amtrakClient = null;

        // Function to fetch live Amtrak train positions
        async function fetchLiveAmtrakTrains() {
            try {
                const now = Date.now();
                if (now - lastAmtrakUpdateTime < 10000) { // Rate limit: 10 seconds for Amtrak
                    return;
                }

                // Check if AmtrakV3Client class is available
                if (typeof AmtrakV3Client === 'undefined') {
    
                    return;
                }

                // Initialize Amtrak client if not already done
                if (!amtrakClient) {
                    amtrakClient = new AmtrakV3Client();
                }

                // Get all active trains
                const trainsData = await amtrakClient.getAllTrains();
                
                if (trainsData && Object.keys(trainsData).length > 0) {
                    // Convert to flat records
                    const trainRecords = AmtrakV3Client.trainsDictToRecords(trainsData);
                    
                    // Update Amtrak train markers on the map
                    updateAmtrakTrainMarkers(trainRecords);
                    
                    lastAmtrakUpdateTime = now;
                }

            } catch (error) {
                console.error('Error fetching Amtrak trains:', error);
                // Don't update lastAmtrakUpdateTime on error to allow retry
            }
                }

        // Function to update Amtrak train markers on the map
        function updateAmtrakTrainMarkers(trains) {
            // Store current popup states before clearing markers
            const currentPopups = new Map();
            amtrakMarkers.forEach((marker, trainId) => {
                if (marker && marker.isPopupOpen && marker.isPopupOpen()) {
                    currentPopups.set(trainId, marker.getPopup().getContent());
                }
            });

            // Clear old Amtrak train markers
            amtrakMarkers.forEach((marker, trainId) => {
                if (marker && marker.remove) {
                    marker.remove();
                }
            });
            amtrakMarkers.clear();

            // Create new Amtrak train markers
            trains.forEach(train => {
                if (train.lat && train.lon && !isNaN(train.lat) && !isNaN(train.lon)) {
                    const trainId = train.trainId || train.trainNum;
                    const lat = parseFloat(train.lat);
                    const lng = parseFloat(train.lon);
                    const heading = train.heading || 0;
                    const velocity = train.velocity;
                    const routeName = train.routeName || 'Amtrak';
                    const trainState = train.state;
                    const statusMsg = train.statusMsg;
                    const origCode = train.origCode;
                    const destCode = train.destCode;

                    // Get route color
                    const routeColor = getAmtrakRouteColor(routeName);

                    // Create Amtrak train marker with custom icon
                    const amtrakIcon = L.icon({
                        iconUrl: 'icons/amtrakcirc.png',
                        iconSize: [28, 28],
                        iconAnchor: [14, 14]
                    });

                    const trainMarker = L.marker([lat, lng], {
                        icon: amtrakIcon,
                        zIndexOffset: 100
                    });

                    // Create popup with train info
                    let popupContent = `
                        <div style="font-size: 11px; line-height: 1.3; margin: 0; padding: 0;">
                            <div style="color: ${routeColor}; font-weight: bold; margin-bottom: 3px;">
                                🚂 Live Amtrak Train
                            </div>
                            <b>Train:</b> ${train.trainNum || 'Unknown'}<br>
                            <b>Route:</b> ${routeName}<br>`;

                    if (origCode && destCode) {
                        popupContent += `<b>Route:</b> ${origCode} → ${destCode}<br>`;
                    }

                    if (velocity !== null && velocity !== undefined && !isNaN(velocity) && velocity > 0) {
                        popupContent += `<b>Speed:</b> ${Math.round(velocity)} mph<br>`;
                    }

                    if (trainState) {
                        popupContent += `<b>Status:</b> ${trainState}<br>`;
                    }

                    if (statusMsg && statusMsg.trim() !== '') {
                        popupContent += `<b>Message:</b> ${statusMsg}<br>`;
                    }

                    popupContent += `
                        <b>Position:</b> ${lat.toFixed(6)}, ${lng.toFixed(6)}<br>
                        <b>Last Update:</b> ${new Date().toLocaleTimeString()}
                        </div>`;

                    // Use tooltip for all trains, direction based on latitude
                    const tooltipDirection = lat < 42.361220 ? 'bottom' : 'top';
                    trainMarker.bindTooltip(popupContent, { 
                        direction: tooltipDirection,
                        permanent: false,
                        interactive: true,
                        className: 'custom-tooltip'
                    });

                    // Store route name with marker for filtering
                    trainMarker.routeName = routeName;
                    
                    // Add click handler to highlight the Amtrak route
                    trainMarker.on('click', function() {
                        // If this route is already highlighted, reset; otherwise highlight it
                        if (isLineHighlighted(routeName)) {
                            resetHighlight();
                        } else {
                            // Load Amtrak routes if not loaded yet (so they can be highlighted)
                            if (!window.amtrakRoutesLoaded && document.getElementById('show-amtrak-paths').checked) {
                                loadAmtrakRoutes();
                            }
                            highlightLine(routeName);
                        }
                    });

                    // Add to map and store reference (only if Amtrak live tracking is checked)
                    if (document.getElementById('show-amtrak-live').checked) {
                        trainMarker.addTo(map);
                    }
                    
                    // Apply highlight opacity if a line is currently highlighted
                    if (highlightedLine && trainMarker) {
                        const isDimmed = trainMarker.routeName !== highlightedLine;
                        const targetOpacity = isDimmed ? 0 : 1.0;
                        if (trainMarker.setOpacity) {
                            trainMarker.setOpacity(targetOpacity);
                        }
                    }
                    
                    amtrakMarkers.set(trainId, trainMarker);

                    // Restore popup if it was open before
                    if (currentPopups.has(trainId)) {
                        trainMarker.openPopup();
                    }


                }
            });


        }

        // Function to load and display Amtrak stations from local file
        async function loadAmtrakStations() {
            try {
                // Load stations from local file
                const response = await fetch('amtrak-stations-data.js');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const stationsData = await response.json();
                
                if (stationsData && stationsData.stations && stationsData.stations.length > 0) {
                    createAmtrakStationMarkers(stationsData.stations);
                } else {
                    throw new Error('No stations found in local file');
                }
            } catch (error) {
                console.error('Error loading Amtrak stations from local file:', error);
                // Fallback to API if local file fails
                await loadAmtrakStationsFromAPI();
            }
        }

        // Function to create Amtrak station markers
        function createAmtrakStationMarkers(stations) {
            // Clear existing station markers if any
            if (window.amtrakStationMarkers) {
                window.amtrakStationMarkers.forEach(marker => {
                    if (marker && marker.remove) marker.remove();
                });
            }
            
            window.amtrakStationMarkers = new Map();
            
            stations.forEach(station => {
                if (station.lat && station.lon && !isNaN(station.lat) && !isNaN(station.lon)) {
                    const lat = parseFloat(station.lat);
                    const lng = parseFloat(station.lon);
                    
                    // Create station marker as a black circle
                    const stationMarker = L.circleMarker([lat, lng], {
                        radius: 4,
                        fillColor: '#000000',
                        color: '#000000',
                        weight: 1,
                        opacity: 1,
                        fillOpacity: 1,
                        zIndexOffset: 500
                    });
                    
                    // Create popup with station info
                    let popupContent = `
                        <div style="font-size: 11px; line-height: 1.3; margin: 0; padding: 0;">
                            <div style="color: #000000; font-weight: bold; margin-bottom: 3px;">
                                🚉 Amtrak Station
                            </div>
                            <b>Name:</b> ${station.name || 'Unknown'}<br>
                            <b>ID:</b> ${station.stationId}<br>`;
                    
                    if (station.city && station.state) {
                        popupContent += `<b>Location:</b> ${station.city}, ${station.state}<br>`;
                    }
                    
                    popupContent += `<b>Position:</b> ${lat.toFixed(6)}, ${lng.toFixed(6)}</div>`;
                    
                    // Use tooltip for all stations, direction based on latitude
                    const tooltipDirection = lat < 42.361220 ? 'bottom' : 'top';
                    stationMarker.bindTooltip(popupContent, { 
                        direction: tooltipDirection,
                        permanent: false,
                        interactive: true,
                        className: 'custom-tooltip'
                    });
                    
                    // Store marker
                    window.amtrakStationMarkers.set(station.stationId, stationMarker);
                    
                    // Add to map if Amtrak paths are shown
                    if (document.getElementById('show-amtrak-paths').checked) {
                        stationMarker.addTo(map);
                    }
                }
            });
            
        }

        // Function to load Amtrak stations from API (fallback)
        async function loadAmtrakStationsFromAPI() {
            try {
                if (!amtrakClient) {
                    amtrakClient = new AmtrakV3Client();
                }

                const stationsData = await amtrakClient.getAllStations();
                
                if (stationsData && Object.keys(stationsData).length > 0) {
                    const stationRecords = AmtrakV3Client.stationsDictToRecords(stationsData);
                    createAmtrakStationMarkers(stationRecords);
                }
                
                // Get feed health status
                await getAmtrakFeedHealth();
            } catch (error) {
                console.error('Error loading Amtrak stations from API:', error);
            }
        }
        
        // Function to get Amtrak feed health status
        async function getAmtrakFeedHealth() {
            try {
                if (!amtrakClient) {
                    amtrakClient = new AmtrakV3Client();
                }

                const healthData = await amtrakClient.getStaleStatus();

                
                // Display health info in console or could be shown on map
                if (healthData) {
                    const avgUpdate = healthData.avgLastUpdate ? new Date(healthData.avgLastUpdate).toLocaleString() : 'Unknown';
                    const activeTrains = healthData.activeTrains || 0;
                    const isStale = healthData.stale || false;
                    
    
                }
                
                return healthData;
            } catch (error) {
                console.error('Error getting Amtrak feed health:', error);
                return null;
            }
        }

        // Function to get specific Amtrak train information
        async function getAmtrakTrainInfo(trainIdOrNum) {
            try {
                if (!amtrakClient) {
                    amtrakClient = new AmtrakV3Client();
                }


                const trainData = await amtrakClient.getTrain(trainIdOrNum);
                
                if (trainData && Object.keys(trainData).length > 0) {
                    const trainRecords = AmtrakV3Client.trainsDictToRecords(trainData);
    
                    return trainRecords;
                } else {
    
                    return null;
                }
            } catch (error) {
                console.error(`Error getting info for train ${trainIdOrNum}:`, error);
                return null;
            }
        }

        // Function to poll specific Amtrak trains
        async function pollAmtrakTrains(trainIdsOrNums = null, intervalSec = 10.0, iterations = 6) {
            const snaps = [];
            
            for (let i = 0; i < iterations; i++) {
                try {
                    let tickData;
                    
                    if (trainIdsOrNums) {
                        // Poll specific trains
                        tickData = {};
                        for (const trainName of trainIdsOrNums) {
                            const d = await amtrakClient.getTrain(trainName) || {};
                            for (const [k, v] of Object.entries(d)) {
                                if (!tickData[k]) tickData[k] = [];
                                tickData[k].push(...(v || []));
                            }
                        }
                    } else {
                        // Poll all trains
                        tickData = await amtrakClient.getAllTrains() || {};
                    }

                    const rows = AmtrakV3Client.trainsDictToRecords(tickData);
                    snaps.push({
                        t_index: i,
                        ts: Date.now() / 1000,
                        rows: rows
                    });

                    const msg = `[${i+1}/${iterations}] fetched ${rows.length} train rows`;
    

                    if (i < iterations - 1) {
                        await new Promise(resolve => setTimeout(resolve, intervalSec * 1000));
                    }
                } catch (error) {
                    console.error(`Error in poll iteration ${i}:`, error);
                }
            }

            return snaps;
                }
        

        
        // Function to load Amtrak routes from local file
        async function loadAmtrakRoutes() {
            try {
                // Load routes from local file
                const response = await fetch('amtrak-routes-data.js');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const routesData = await response.json();
                
                if (routesData && routesData.routes && routesData.routes.length > 0) {
                    createAmtrakRouteLayersFromLocal(routesData.routes);
                    window.amtrakRoutesLoaded = true;
                } else {
                    throw new Error('No routes found in local file');
                }
            } catch (error) {
                console.error('Error loading Amtrak routes from local file:', error);
                // Fallback to API if local file fails
                await loadAmtrakRoutesFromAPI();
            }
        }
        
        // Function to load Amtrak routes from USDOT NTAD ArcGIS service
        async function loadAmtrakRoutesFromAPI() {
            try {
                // ArcGIS Feature Server URL for Amtrak routes
                const baseUrl = 'https://services.arcgis.com/xOi1kZaI0eWDREZv/ArcGIS/rest/services/NTAD_Amtrak_Routes/FeatureServer/0/query';
                
                const params = new URLSearchParams({
                    where: '1=1',
                    outFields: '*',
                    outSR: 4326,
                    f: 'geojson',
                    returnGeometry: 'true'
                });
                
                const response = await fetch(`${baseUrl}?${params.toString()}`, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const routesGeojson = await response.json();
                
                if (!routesGeojson.features || routesGeojson.features.length === 0) {
                    throw new Error('No Amtrak routes found');
                }
                
                // Create route layers and add to map
                createAmtrakRouteLayers(routesGeojson.features);
                window.amtrakRoutesLoaded = true;
                
            } catch (error) {
                console.error('Error loading Amtrak routes from USDOT NTAD:', error);
                // No fallback - just log the error
            }
        }
        
        // Function to create Amtrak route layers from local data
        function createAmtrakRouteLayersFromLocal(routes) {
            if (!window.amtrakRouteLayers) {
                window.amtrakRouteLayers = {};
            }
            
            // Ensure the layer group exists
            if (!window.amtrakRouteLayerGroup) {
                window.amtrakRouteLayerGroup = L.layerGroup().addTo(map);
            }
            
            routes.forEach(route => {
                if (route.coordinates && route.coordinates.length > 0) {
                    const routeName = route.name || 'Amtrak Route';
                    const color = getAmtrakRouteColor(routeName);
                    
                    // Convert coordinates to Leaflet format if needed
                    let latlngs;
                    if (route.geometryType === 'MultiLineString') {
                        latlngs = route.coordinates.map(line => 
                            line.map(coord => [coord[1], coord[0]]) // [lat, lng]
                        );
                    } else {
                        latlngs = route.coordinates.map(coord => [coord[1], coord[0]]); // [lat, lng]
                    }
                    
                    const polyline = L.polyline(latlngs, {
                        color: '#000000',
                        weight: 3,
                        opacity: 0.8
                    });
                    
                    polyline.routeName = routeName;
                    window.amtrakRouteLayers[routeName] = polyline;
                    
                    // Add popup with route info
                    const popupContent = `
                        <div style="color: #000000;">
                            <strong>${routeName}</strong><br>
                            ${route.properties ? `State: ${route.properties.STATE || 'N/A'}<br>` : ''}
                            ${route.properties ? `Length: ${route.properties.LENGTH_MI ? Math.round(route.properties.LENGTH_MI) + ' mi' : 'N/A'}<br>` : ''}
                            ${route.properties ? `Owner: ${route.properties.OWNER || 'N/A'}` : ''}
                        </div>
                    `;
                    polyline.bindPopup(popupContent);
                    
                    // Add click handler to highlight the Amtrak route
                    polyline.on('click', function() {
                        if (isLineHighlighted(routeName)) {
                            resetHighlight();
                        } else {
                            highlightLine(routeName);
                        }
                    });
                    
                    // Add to map
                    polyline.addTo(window.amtrakRouteLayerGroup);
                }
            });
        }
        
        // Function to create Amtrak route layers from GeoJSON features
        function createAmtrakRouteLayers(features) {
            if (!window.amtrakRouteLayers) {
                window.amtrakRouteLayers = {};
            }
            
            let processedCount = 0;
            let skippedCount = 0;
            
            features.forEach((feature, index) => {
                try {
                    const properties = feature.properties;
                    const geometry = feature.geometry;
                    

                    
                    // Extract route information
                    let routeName = 'Amtrak';
                    if (properties.ROUTE_NAME) {
                        routeName = properties.ROUTE_NAME;
                    } else if (properties.NAME) {
                        routeName = properties.NAME;
                    } else if (properties.ROUTE) {
                        routeName = properties.ROUTE;
                    }
                    
                    // Get route color
                    const routeColor = getAmtrakRouteColor(routeName);
                    
                    // Handle different geometry types
                    let routeLine = null;
                    
                    if (geometry && geometry.coordinates && geometry.coordinates.length > 0) {
                        if (geometry.type === 'LineString') {
                            // Convert coordinates from [longitude, latitude] to [latitude, longitude] for Leaflet
                            const latLngCoords = geometry.coordinates.map(coord => [coord[1], coord[0]]);
                            
                            routeLine = L.polyline(latLngCoords, {
                                color: '#000000',
                                weight: 3,
                                opacity: 0.8
                            });
                        } else if (geometry.type === 'MultiLineString') {
                            // Handle multi-line strings (routes with multiple segments)
                            const latLngCoords = geometry.coordinates.map(line => 
                                line.map(coord => [coord[1], coord[0]])
                            );
                            
                            routeLine = L.polyline(latLngCoords, {
                                color: '#000000',
                                weight: 3,
                                opacity: 0.8
                            });
                        }
                    }
                    
                    if (routeLine) {
                        // Create popup with route information
                        let popupContent = `
                            <div style="color: ${routeColor}; font-weight: bold;">
                                🚂 Amtrak Route
                            </div>
                            <b>Route:</b> ${routeName}<br>`;
                        
                        // Add additional properties if available
                        if (properties.STATE) {
                            popupContent += `<b>State:</b> ${properties.STATE}<br>`;
                        }
                        if (properties.LENGTH_MI) {
                            popupContent += `<b>Length:</b> ${properties.LENGTH_MI} miles<br>`;
                        }
                        if (properties.OWNER) {
                            popupContent += `<b>Owner:</b> ${properties.OWNER}<br>`;
                        }
                        
                        popupContent += `<b>Type:</b> Passenger Rail<br>
                            <b>Last Updated:</b> ${new Date().toLocaleDateString()}`;
                        
                        routeLine.bindPopup(popupContent);
                        
                        // Store route name with the layer
                        routeLine.routeName = routeName;
                        
                        // Add click handler to highlight the Amtrak route
                        routeLine.on('click', function() {
                            if (isLineHighlighted(routeName)) {
                                resetHighlight();
                            } else {
                                highlightLine(routeName);
                            }
                        });
                        
                        // Store the layer
                        const layerKey = `amtrak_${index}`;
                        window.amtrakRouteLayers[layerKey] = routeLine;
                        
                        // Add to map if Amtrak paths are currently shown
                        if (document.getElementById('show-amtrak-paths').checked) {
                            routeLine.addTo(map);
                        }
                        
                        processedCount++;

                    } else {
                        skippedCount++;

                    }
                    
                } catch (error) {
                    console.error(`Error processing Amtrak route ${index}:`, error);
                    skippedCount++;
                }
            });
            
        }
        
        // Function to get color for Amtrak routes
        function getAmtrakRouteColor(routeName) {
            const routeNameLower = routeName.toLowerCase();
            
            // Match specific route names to colors
            if (routeNameLower.includes('northeast corridor') || routeNameLower.includes('nec')) {
                return lineColors['Northeast Corridor'] || '#DC2626';
            } else if (routeNameLower.includes('acela')) {
                return lineColors['Acela'] || '#7C2D12';
            } else if (routeNameLower.includes('vermouter') || routeNameLower.includes('vermont')) {
                return lineColors['Vermonter'] || '#059669';
            } else if (routeNameLower.includes('downeaster') || routeNameLower.includes('maine')) {
                return lineColors['Downeaster'] || '#7C3AED';
            } else if (routeNameLower.includes('lake shore') || routeNameLower.includes('chicago')) {
                return lineColors['Lake Shore Limited'] || '#EA580C';
            } else if (routeNameLower.includes('empire') || routeNameLower.includes('new york')) {
                return lineColors['Empire Service'] || '#BE185D';
            } else {
                // Default Amtrak blue for other routes
                return lineColors['Amtrak'] || '#1E3A8A';
            }
        }
        

        

        
        // Function to update train markers on the map
        function updateTrainMarkers(trains) {
            // Store current popup states before clearing markers
            const currentPopups = new Map();
            trainMarkers.forEach((marker, trainId) => {
                if (marker && marker.isPopupOpen && marker.isPopupOpen()) {
                    currentPopups.set(trainId, marker.getPopup().getContent());
                }
            });
            
            // Clear old train markers
            trainMarkers.forEach((marker, trainId) => {
                if (marker && marker.remove) {
                    marker.remove();
                }
            });
            trainMarkers.clear();
            
            // Create new train markers
                            trains.forEach(train => {
                    if (train.attributes && train.attributes.latitude && train.attributes.longitude) {
                        const trainId = train.id; // Vehicle ID (physical train)
                        const tripId = train.relationships?.trip?.data?.id; // Trip ID (scheduled run)
                        const lat = train.attributes.latitude;
                        const lng = train.attributes.longitude;
                        const heading = train.attributes.heading || 0;
                        const speed = train.attributes.speed;
                        const currentStatus = train.attributes.current_status;
                        const routeId = train.relationships?.route?.data?.id;
                        const label = train.attributes.label; // Train car number/label
                        

                        

                    
                    // Get route name and color with better matching
                    let routeName = 'Unknown Route';
                    let color = '#666';
                    
                    if (routeId && mbtaStopsData) {

                        
                        // Better route matching logic
                        if (mbtaStopsData) {
                            Object.keys(mbtaStopsData).forEach(name => {
                                // Check for exact matches first
                                if (name === routeId || 
                                    name.replace(/\s+/g, '') === routeId ||
                                    name.replace(/\s+/g, '') === routeId.replace(/\s+/g, '') ||
                                    routeId.includes(name.replace(/\s+/g, '')) ||
                                    name.includes(routeId.replace(/\s+/g, ''))) {
                                    routeName = name;
                                    color = lineColors[name] || '#666';
                                }
                            });
                            
                            // If no match found, try partial matching for commuter rail
                            if (routeName === 'Unknown Route' && routeId.startsWith('CR-')) {
                                // First try to match against mbtaStopsData
                                Object.keys(mbtaStopsData).forEach(name => {
                                    if (name.includes('Line') && routeId.includes(name.split(' ')[0])) {
                                        routeName = name;
                                        color = lineColors[name] || '#800080'; // Default purple for commuter rail
                                    }
                                });
                                
                                // If still no match, try to match against commuterLines array
                                if (routeName === 'Unknown Route') {
                                    const routeSuffix = routeId.substring(3); // Remove "CR-" prefix
                                    const routeSuffixNoSpaces = routeSuffix.replace(/\s+/g, '').toLowerCase();
                                    
                                    commuterLines.forEach(lineName => {
                                        const lineNameNoSpaces = lineName.replace(/\s+/g, '').toLowerCase();
                                        
                                        // Match without spaces (e.g., "NewBedford" matches "New Bedford")
                                        if (lineNameNoSpaces.includes(routeSuffixNoSpaces) || 
                                            routeSuffixNoSpaces.includes(lineNameNoSpaces.split('/')[0]) ||
                                            lineName.toLowerCase().includes(routeSuffix.toLowerCase()) || 
                                            routeSuffix.toLowerCase().includes(lineName.split(' ')[0].toLowerCase())) {
                                            routeName = lineName;
                                            color = lineColors[lineName] || '#800080'; // Default purple for commuter rail
                                        }
                                    });
                                }
                            }
                            
                            // If still no match, try to identify Green Line routes specifically
                            if (routeName === 'Unknown Route' && (routeId.includes('Green') || routeId.includes('GL'))) {
                                // Try to match specific Green Line branch
                                if (routeId.includes('Green-B') || routeId.includes('GL-B')) {
                                    routeName = 'Green Line B';
                                } else if (routeId.includes('Green-C') || routeId.includes('GL-C')) {
                                    routeName = 'Green Line C';
                                } else if (routeId.includes('Green-D') || routeId.includes('GL-D')) {
                                    routeName = 'Green Line D';
                                } else if (routeId.includes('Green-E') || routeId.includes('GL-E')) {
                                    routeName = 'Green Line E';
                                } else {
                                    routeName = 'Green Line';
                                }
                                color = lineColors['Green Line B'] || '#00843D';
                            }
                        }
                    }
                    
                    // Create train marker with custom line-specific icons
                    let trainIcon;
                    
                    if (routeName.includes('Red Line') || routeName.includes('Mattapan')) {
                        trainIcon = L.icon({
                            iconUrl: 'icons/readlinecirc.png',
                            iconSize: [24, 24],
                            iconAnchor: [12, 12]
                        });
                    } else if (routeName.includes('Blue Line')) {
                        trainIcon = L.icon({
                            iconUrl: 'icons/bluelinecirc.png',
                            iconSize: [24, 24],
                            iconAnchor: [12, 12]
                        });
                    } else if (routeName.includes('Green Line') || routeName.includes('Green-')) {
                        trainIcon = L.icon({
                            iconUrl: 'icons/greenlinecirc.png',
                            iconSize: [24, 24],
                            iconAnchor: [12, 12]
                        });
                    } else if (routeName.includes('Orange Line')) {
                        trainIcon = L.icon({
                            iconUrl: 'icons/orangelinecirc.png',
                            iconSize: [24, 24],
                            iconAnchor: [12, 12]
                        });
                    } else {
                        // Use commuter rail icon for all other routes (CapeFlyer, Fairmount, etc.)
                        trainIcon = L.icon({
                            iconUrl: 'icons/commuterrailcirc.png',
                            iconSize: [24, 24],
                            iconAnchor: [12, 12]
                        });
                    }
                    
                    const trainMarker = L.marker([lat, lng], {
                        icon: trainIcon,
                        zIndexOffset: 200
                    });
                    
                    // Get direction information (inbound/outbound)
                    const direction = train.attributes.direction_id === 0 ? 'Inbound' : 'Outbound';
                    
                    // Create popup with train info
                    let popupContent = `
                        <div style="font-size: 11px; line-height: 1.3; margin: 0; padding: 0;">
                            <div style="color: ${color}; font-weight: bold; margin-bottom: 3px;">
                                <img src="${trainIcon.options.iconUrl}" style="width: 16px; height: 16px; vertical-align: middle; margin-right: 4px;">
                                Live Train
                            </div>
                            <b>Route:</b> ${routeName === 'Unknown Route' ? (routeId.startsWith('CR-') ? routeId.substring(3) + ' Line' : routeId) : routeName}<br>`;
                    
                    // Only show speed if it's a valid number
                    if (speed !== null && speed !== undefined && speed !== 'none' && !isNaN(speed) && speed > 0) {
                        popupContent += `<b>Speed:</b> ${Math.round(speed)} mph<br>`;
                    }
                    
                    // Add current status if available
                    if (currentStatus) {
                        let statusText = currentStatus;
                        if (currentStatus === 'STOPPED_AT') {
                            statusText = 'Stopped';
                        } else if (currentStatus === 'IN_TRANSIT_TO') {
                            statusText = 'In Transit';
                        } else if (currentStatus === 'INCOMING_AT') {
                            statusText = 'Incoming';
                        }
                        popupContent += `<b>Status:</b> ${statusText}<br>`;
                    }
                    
                    popupContent += `<b>Vehicle ID:</b> ${trainId}<br>`;
                    
                    // Show trip ID if available (simplified to show only the last number)
                    if (tripId) {
                        const simplifiedTripId = tripId.includes('-') ? tripId.split('-').pop() : tripId;
                        popupContent += `<b>Trip ID:</b> ${simplifiedTripId}<br>`;
                    }
                    
                    // Show terminus for specific lines, direction ID for others
                    if (routeName.includes('Red Line')) {
                        if (train.attributes.direction_id === 1) {
                            popupContent += `<b>Terminus:</b> Alewife<br>`;
                        } else {
                            popupContent += `<b>Terminus:</b> Ashmont/Braintree<br>`;
                        }
                    } else if (routeName.includes('Orange Line')) {
                        if (train.attributes.direction_id === 1) {
                            popupContent += `<b>Terminus:</b> Oak Grove<br>`;
                        } else {
                            popupContent += `<b>Terminus:</b> Forest Hills<br>`;
                        }
                    } else if (routeName.includes('Blue Line')) {
                        if (train.attributes.direction_id === 1) {
                            popupContent += `<b>Terminus:</b> Wonderland<br>`;
                        } else {
                            popupContent += `<b>Terminus:</b> Bowdoin<br>`;
                        }
                    } else if (routeName.includes('Green Line B')) {
                        if (train.attributes.direction_id === 1) {
                            popupContent += `<b>Terminus:</b> Government Center<br>`;
                        } else {
                            popupContent += `<b>Terminus:</b> Boston College<br>`;
                        }
                    } else if (routeName.includes('Green Line C')) {
                        if (train.attributes.direction_id === 1) {
                            popupContent += `<b>Terminus:</b> Government Center<br>`;
                        } else {
                            popupContent += `<b>Terminus:</b> Cleveland Circle<br>`;
                        }
                    } else if (routeName.includes('Green Line D')) {
                        if (train.attributes.direction_id === 1) {
                            popupContent += `<b>Terminus:</b> Union Square<br>`;
                        } else {
                            popupContent += `<b>Terminus:</b> Riverside<br>`;
                        }
                    } else if (routeName.includes('Green Line E')) {
                        if (train.attributes.direction_id === 1) {
                            popupContent += `<b>Terminus:</b> Medford/Tufts<br>`;
                        } else {
                            popupContent += `<b>Terminus:</b> Heath Street<br>`;
                        }
                    } else {
                        // Handle commuter rail and other routes with terminus logic
                        if (routeId && routeId.startsWith('CR-')) {
                            const lineName = routeId.substring(3); // Remove "CR-" prefix
                            const northStationLines = ['Fitchburg', 'Lowell', 'Rockport', 'Newburyport', 'Haverhill'];
                            
                            if (train.attributes.direction_id === 0) {
                                // Outbound: show the line's terminus
                                popupContent += `<b>Terminus:</b> ${lineName}<br>`;
                            } else {
                                // Inbound: show Boston station
                                const terminus = northStationLines.includes(lineName) ? 'North Station' : 'South Station';
                                popupContent += `<b>Terminus:</b> ${terminus}<br>`;
                            }
                        } else {
                            popupContent += `<b>Direction ID:</b> ${train.attributes.direction_id}<br>`;
                        }
                    }
                    
                    popupContent += `
                        <b>Position:</b> ${lat.toFixed(6)}, ${lng.toFixed(6)}<br>
                        <b>Last Update:</b> ${new Date().toLocaleTimeString()}
                        </div>
                    `;
                    
                    // Use tooltip for all trains, direction based on latitude
                    const tooltipDirection = lat < 42.361220 ? 'bottom' : 'top';
                    trainMarker.bindTooltip(popupContent, { 
                        direction: tooltipDirection,
                        permanent: false,
                        interactive: true,
                        className: 'custom-tooltip'
                    });
                    
                    // Store route name and ID with marker for filtering
                    trainMarker.routeName = routeName;
                    trainMarker.routeId = routeId;
                    
                    // Add click handler to highlight the line (for both subway and commuter rail)
                    trainMarker.on('click', function() {
                        if (subwayLines.includes(routeName) || commuterLines.includes(routeName) || routeId.startsWith('CR-')) {
                            // If this line is already highlighted, reset; otherwise highlight it
                            if (isLineHighlighted(routeName)) {
                                resetHighlight();
                            } else {
                                highlightLine(routeName);
                            }
                        }
                    });
                    
                    // Add to map and store reference (only if the category is checked)
                    let shouldShow = false;
                    
                    // Check if this train should be shown based on live tracking checkbox states
                    // IMPORTANT: Check commuter rail FIRST before subway, since commuter rail lines also contain "Line"
                    if ((commuterLines.includes(routeName) || (routeId && routeId.startsWith('CR-'))) && document.getElementById('show-commuter-live').checked) {
                        shouldShow = true;
                    } else if (seasonalLines.includes(routeName) && document.getElementById('show-seasonal-live').checked) {
                        shouldShow = true;
                    } else if (subwayLines.includes(routeName) && document.getElementById('show-subway-live').checked) {
                        shouldShow = true;
                    }
                    
                    if (shouldShow) {
                        trainMarker.addTo(map);
                    }
                    
                    // Apply highlight opacity if a line is currently highlighted
                    if (highlightedLine && trainMarker) {
                        const isDimmed = trainMarker.routeName !== highlightedLine;
                        const targetOpacity = isDimmed ? 0 : 1.0;
                        if (trainMarker.setOpacity) {
                            trainMarker.setOpacity(targetOpacity);
                        }
                    }
                    
                    trainMarkers.set(trainId, trainMarker);
                    
                    // Restore popup if it was open before
                    if (currentPopups.has(trainId)) {
                        trainMarker.openPopup();
                    }
                }
            });
            

        }
        
        // Function to update bus markers on the map
        function updateBusMarkers(buses) {
            // Store current popup states before clearing markers
            const currentBusPopups = new Map();
            busMarkers.forEach((marker, busId) => {
                if (marker && marker.isPopupOpen && marker.isPopupOpen()) {
                    currentBusPopups.set(busId, marker.getPopup().getContent());
                }
            });
            const currentShuttlePopups = new Map();
            shuttleMarkers.forEach((marker, shuttleId) => {
                if (marker && marker.isPopupOpen && marker.isPopupOpen()) {
                    currentShuttlePopups.set(shuttleId, marker.getPopup().getContent());
                }
            });
            
            // Clear old bus markers
            busMarkers.forEach((marker, busId) => {
                if (marker && marker.remove) {
                    marker.remove();
                }
            });
            busMarkers.clear();
            
            // Clear old shuttle markers
            shuttleMarkers.forEach((marker, shuttleId) => {
                if (marker && marker.remove) {
                    marker.remove();
                }
            });
            shuttleMarkers.clear();
            
            // Create new bus/shuttle markers
            buses.forEach(bus => {
                if (bus.attributes && bus.attributes.latitude && bus.attributes.longitude) {
                    const vehicleId = bus.id; // Vehicle ID (physical bus)
                    const tripId = bus.relationships?.trip?.data?.id; // Trip ID (scheduled run)
                    const lat = bus.attributes.latitude;
                    const lng = bus.attributes.longitude;
                    const heading = bus.attributes.heading || 0;
                    const speed = bus.attributes.speed;
                    const currentStatus = bus.attributes.current_status;
                    const routeId = bus.relationships?.route?.data?.id;
                    const label = bus.attributes.label; // Bus number/label
                    
                    // Check if this is a shuttle
                    const isShuttle = routeId && (
                        routeId.startsWith('Shuttle-') ||
                        (typeof mbtaShuttleData !== 'undefined' && mbtaShuttleData[routeId])
                    );
                    
                    // Check if this is a Silver Line vehicle (route IDs: 741, 742, 743, 749, 751, 746)
                    const silverLineRoutes = ['741', '742', '743', '749', '751', '746'];
                    const isSilverLine = routeId && silverLineRoutes.includes(routeId);
                    
                    // Determine vehicle type and default colors
                    let vehicleType, color;
                    if (isSilverLine) {
                        vehicleType = 'Silver Line';
                        color = '#7C878E'; // Silver Line color
                    } else if (isShuttle) {
                        vehicleType = 'Shuttle';
                        color = '#FF6B6B'; // Shuttle red
                    } else {
                        vehicleType = 'Bus';
                        color = '#FFD700'; // Bus gold
                    }
                    
                    // Get route name
                    let routeName = `Unknown ${vehicleType} Route`;
                    
                    if (routeId) {
                        // Get proper route name based on vehicle type
                        if (isSilverLine) {
                            // Map Silver Line route IDs to their display names
                            const silverLineNames = {
                                '741': 'SL1',
                                '742': 'SL2',
                                '743': 'SL3',
                                '751': 'SL4',
                                '749': 'SL5',
                                '746': 'SLW'
                            };
                            const slName = silverLineNames[routeId] || routeId;
                            routeName = `Silver Line ${slName}`;
                            color = lineColors[slName] || color;
                        } else if (isShuttle) {
                            routeName = `Shuttle ${routeId}`;
                            color = lineColors[routeId] || color;
                        } else {
                            routeName = `Bus Route ${routeId}`;
                            color = lineColors[routeId] || color;
                        }
                        
                        // Ensure this route has a layer (create one if it doesn't exist)
                        // For Silver Line, we need to use the display name as the layer key
                        let layerKey = routeId;
                        if (isSilverLine) {
                            const silverLineNames = {
                                '741': 'SL1',
                                '742': 'SL2',
                                '743': 'SL3',
                                '751': 'SL4',
                                '749': 'SL5',
                                '746': 'SLW'
                            };
                            layerKey = silverLineNames[routeId] || routeId;
                        }
                        
                        if (!layers[layerKey]) {
                            layers[layerKey] = L.layerGroup();
                        }
                    }
                    
                    // Create marker with appropriate icon based on vehicle type
                    let iconUrl = 'icons/buscirc.png'; // Default to bus icon
                    if (isSilverLine) {
                        iconUrl = 'icons/silverlinecirc.png';
                    }
                    
                    const vehicleIcon = L.icon({
                        iconUrl: iconUrl,
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    });
                    
                    const vehicleMarker = L.marker([lat, lng], {
                        icon: vehicleIcon,
                        zIndexOffset: 250
                    });
                    
                    // Get direction information (inbound/outbound)
                    const direction = bus.attributes.direction_id === 0 ? 'Inbound' : 'Outbound';
                    
                    // Create popup with vehicle info
                    let popupContent = `
                        <div style="font-size: 11px; line-height: 1.3; margin: 0; padding: 0;">
                            <div style="color: ${color}; font-weight: bold; margin-bottom: 3px;">
                                <img src="${vehicleIcon.options.iconUrl}" style="width: 16px; height: 16px; vertical-align: middle; margin-right: 4px;">
                                Live ${vehicleType}
                            </div>
                            <b>Route:</b> ${routeName}<br>
                            <b>Direction:</b> ${direction}<br>`;
                    
                    // Only show speed if it's a valid number
                    if (speed !== null && speed !== undefined && speed !== 'none' && !isNaN(speed) && speed > 0) {
                        popupContent += `<b>Speed:</b> ${Math.round(speed)} mph<br>`;
                    }
                    
                    // Show status if available
                    if (currentStatus && currentStatus !== 'none') {
                        let statusText = currentStatus;
                        if (currentStatus === 'STOPPED_AT') {
                            statusText = 'Stopped';
                        } else if (currentStatus === 'IN_TRANSIT_TO') {
                            statusText = 'In Transit';
                        } else if (currentStatus === 'INCOMING_AT') {
                            statusText = 'Incoming';
                        }
                        popupContent += `<b>Status:</b> ${statusText}<br>`;
                    }
                    
                    popupContent += `<b>Vehicle ID:</b> ${vehicleId}<br>`;
                    
                    // Show trip ID if available (simplified to show only the last number)
                    if (tripId) {
                        const simplifiedTripId = tripId.includes('-') ? tripId.split('-').pop() : tripId;
                        popupContent += `<b>Trip ID:</b> ${simplifiedTripId}<br>`;
                    }
                    
                    popupContent += `
                        <b>Position:</b> ${lat.toFixed(6)}, ${lng.toFixed(6)}<br>
                        <b>Last Update:</b> ${new Date().toLocaleTimeString()}
                        </div>
                    `;
                    
                    // Use tooltip for all vehicles, direction based on latitude
                    const tooltipDirection = lat < 42.361220 ? 'bottom' : 'top';
                    vehicleMarker.bindTooltip(popupContent, { 
                        direction: tooltipDirection,
                        permanent: false,
                        interactive: true,
                        className: 'custom-tooltip'
                    });
                    
                    // Store route name with marker for filtering
                    // For Silver Line, use display name (SL1, SL2, etc.) to match layer keys
                    // For others, use routeId
                    let markerRouteKey = routeId;
                    if (isSilverLine) {
                        const silverLineNames = {
                            '741': 'SL1',
                            '742': 'SL2',
                            '743': 'SL3',
                            '751': 'SL4',
                            '749': 'SL5',
                            '746': 'SLW'
                        };
                        markerRouteKey = silverLineNames[routeId] || routeId;
                    }
                    
                    vehicleMarker.routeName = markerRouteKey; // Use for layer matching
                    vehicleMarker.apiRouteId = routeId; // Store API route ID for filtering
                    vehicleMarker.displayName = routeName; // Keep formatted name for display
                    
                    // Add click handler to highlight the route
                    vehicleMarker.on('click', function() {
                        // If this route is already highlighted, reset; otherwise highlight it
                        if (isLineHighlighted(markerRouteKey)) {
                            resetHighlight();
                        } else {
                            // Ensure routes are loaded before highlighting
                            if (isSilverLine) {
                                if (!silverLineLoaded && document.getElementById('show-silver-line-paths').checked) {
                                    loadSilverLine(true);
                                }
                            } else if (isShuttle) {
                                if (!shuttleRoutesLoaded && document.getElementById('show-shuttle-paths').checked) {
                                    loadShuttleRoutesChunked(true);
                                }
                            } else {
                                if (!busRoutesLoaded && document.getElementById('show-bus-paths').checked) {
                                    loadBusRoutesChunked(true);
                                }
                            }
                            
                            // Always highlight the route (layer will be created even if empty)
                            highlightLine(markerRouteKey);
                        }
                    });
                    
                    // Add to map and store reference based on vehicle type
                    if (isSilverLine) {
                        // Add to map if Silver Line live tracking checkbox is checked
                        if (document.getElementById('show-silver-line-live').checked) {
                            vehicleMarker.addTo(map);
                        }
                        
                        // Apply highlight opacity if a line is currently highlighted
                        if (highlightedLine !== null) {
                            const shouldDim = Array.isArray(highlightedLine) 
                                ? !highlightedLine.includes(markerRouteKey)
                                : highlightedLine !== markerRouteKey;
                            
                            if (shouldDim) {
                                vehicleMarker.setOpacity(0);
                            }
                        }
                        
                        // Store in busMarkers (Silver Line uses bus API)
                        busMarkers.set(vehicleId, vehicleMarker);
                    } else if (isShuttle) {
                        // Add to map if shuttle live tracking checkbox is checked
                        if (document.getElementById('show-shuttle-live').checked) {
                            vehicleMarker.addTo(map);
                        }
                        
                        // Apply highlight opacity if a line is currently highlighted
                        if (highlightedLine && vehicleMarker) {
                            const isHighlightedArray = Array.isArray(highlightedLine);
                            const isDimmed = isHighlightedArray 
                                ? !highlightedLine.includes(vehicleMarker.routeName)
                                : vehicleMarker.routeName !== highlightedLine;
                            const targetOpacity = isDimmed ? 0 : 1.0;
                            if (vehicleMarker.setOpacity) {
                                vehicleMarker.setOpacity(targetOpacity);
                            }
                        }
                        
                        shuttleMarkers.set(vehicleId, vehicleMarker);
                        
                        // Restore popup if it was open before
                        if (currentShuttlePopups.has(vehicleId)) {
                            vehicleMarker.openPopup();
                        }
                    } else {
                        // Add to map if bus live tracking checkbox is checked
                        if (document.getElementById('show-bus-live').checked) {
                            vehicleMarker.addTo(map);
                        }
                        
                        // Apply highlight opacity if a line is currently highlighted
                        if (highlightedLine && vehicleMarker) {
                            const isHighlightedArray = Array.isArray(highlightedLine);
                            const isDimmed = isHighlightedArray 
                                ? !highlightedLine.includes(vehicleMarker.routeName)
                                : vehicleMarker.routeName !== highlightedLine;
                            const targetOpacity = isDimmed ? 0 : 1.0;
                            if (vehicleMarker.setOpacity) {
                                vehicleMarker.setOpacity(targetOpacity);
                            }
                        }
                        
                        busMarkers.set(vehicleId, vehicleMarker);
                        
                        // Restore popup if it was open before
                        if (currentBusPopups.has(vehicleId)) {
                            vehicleMarker.openPopup();
                        }
                    }
                }
            });
        }
        
        // Function to update ferry markers on the map
        function updateFerryMarkers(ferries) {
            // Clear old ferry markers
            ferryMarkers.forEach((marker, ferryId) => {
                if (marker && marker.remove) {
                    marker.remove();
                }
            });
            ferryMarkers.clear();
            
            // Create new ferry markers
            ferries.forEach(ferry => {
                if (ferry.attributes && ferry.attributes.latitude && ferry.attributes.longitude) {
                    const ferryId = ferry.id; // Vehicle ID (physical ferry)
                    const tripId = ferry.relationships?.trip?.data?.id; // Trip ID (scheduled run)
                    const lat = ferry.attributes.latitude;
                    const lng = ferry.attributes.longitude;
                    const heading = ferry.attributes.heading || 0;
                    const speed = ferry.attributes.speed;
                    const currentStatus = ferry.attributes.current_status;
                    const routeId = ferry.relationships?.route?.data?.id;
                    const label = ferry.attributes.label; // Ferry name/label
                    
                    // Get route name and color
                    let routeName = 'Unknown Ferry Route';
                    let color = '#008EAA'; // Default ferry blue
                    
                    if (routeId && mbtaFerryData) {
                        if (mbtaFerryData[routeId]) {
                            routeName = mbtaFerryData[routeId][0]?.name || routeId;
                            color = lineColors[routeId] || '#008EAA';
                        }
                    }
                    
                    // Create ferry marker with boat icon
                    const ferryIcon = L.icon({
                        iconUrl: 'icons/commuterrailcirc.png', // Use commuter rail icon for now
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    });
                    
                    const ferryMarker = L.marker([lat, lng], {
                        icon: ferryIcon,
                        zIndexOffset: 300
                    });
                    
                    // Create popup with ferry info
                    let popupContent = `
                        <div style="font-size: 11px; line-height: 1.3; margin: 0; padding: 0;">
                            <div style="color: ${color}; font-weight: bold; margin-bottom: 3px;">
                                <img src="${ferryIcon.options.iconUrl}" style="width: 16px; height: 16px; vertical-align: middle; margin-right: 4px;">
                                Live Ferry
                            </div>
                            <b>Route:</b> ${routeName}<br>`;
                    
                    // Only show speed if it's a valid number
                    if (speed !== null && speed !== undefined && speed !== 'none' && !isNaN(speed) && speed > 0) {
                        popupContent += `<b>Speed:</b> ${Math.round(speed)} mph<br>`;
                    }
                    
                    // Add current status if available
                    if (currentStatus) {
                        let statusText = currentStatus;
                        if (currentStatus === 'STOPPED_AT') {
                            statusText = 'Stopped';
                        } else if (currentStatus === 'IN_TRANSIT_TO') {
                            statusText = 'In Transit';
                        } else if (currentStatus === 'INCOMING_AT') {
                            statusText = 'Incoming';
                        }
                        popupContent += `<b>Status:</b> ${statusText}<br>`;
                    }
                    
                    popupContent += `<b>Vehicle ID:</b> ${ferryId}<br>`;
                    
                    // Show trip ID if available (simplified to show only the last number)
                    if (tripId) {
                        const simplifiedTripId = tripId.includes('-') ? tripId.split('-').pop() : tripId;
                        popupContent += `<b>Trip ID:</b> ${simplifiedTripId}<br>`;
                    }
                    
                    popupContent += `
                        <b>Position:</b> ${lat.toFixed(6)}, ${lng.toFixed(6)}<br>
                        <b>Last Update:</b> ${new Date().toLocaleTimeString()}
                        </div>
                    `;
                    
                    // Use tooltip for all ferries, direction based on latitude
                    const tooltipDirection = lat < 42.361220 ? 'bottom' : 'top';
                    ferryMarker.bindTooltip(popupContent, { 
                        direction: tooltipDirection,
                        permanent: false,
                        interactive: true,
                        className: 'custom-tooltip'
                    });
                    
                    // Add to map and store reference
                    ferryMarker.addTo(map);
                    ferryMarkers.set(ferryId, ferryMarker);
                }
            });
        }
        
        // Start live tracking
        function startLiveTracking() {
            if (trackingInterval) {
                clearInterval(trackingInterval);
            }
            if (amtrakTrackingInterval) {
                clearInterval(amtrakTrackingInterval);
            }
            if (busTrackingInterval) {
                clearInterval(busTrackingInterval);
            }
            
            // Initial fetch
            fetchLiveTrains();
            fetchLiveAmtrakTrains();
            fetchLiveBuses();
            
            // Set up interval for updates
            trackingInterval = setInterval(fetchLiveTrains, 5000); // Update every 5 seconds
            amtrakTrackingInterval = setInterval(fetchLiveAmtrakTrains, 10000); // Update every 10 seconds for Amtrak
            busTrackingInterval = setInterval(fetchLiveBuses, 5000); // Update every 5 seconds for buses
            
            console.log('Live tracking started');
        }
        

        
        // Stop live tracking for a specific category
        function stopLiveTrackingForCategory(category) {
            // Clear markers for the specific category
            if (category === 'subway') {
                // Clear subway train markers
                trainMarkers.forEach((marker, trainId) => {
                    if (marker && marker.routeName && subwayLines.includes(marker.routeName)) {
                        if (marker.remove) marker.remove();
                    }
                });
            } else if (category === 'commuter') {
                // Clear commuter rail train markers
                trainMarkers.forEach((marker, trainId) => {
                    if (marker && marker.routeName && (commuterLines.includes(marker.routeName) || (marker.routeId && marker.routeId.startsWith('CR-')))) {
                        if (marker.remove) marker.remove();
                    }
                });
            } else if (category === 'amtrak') {
                // Clear Amtrak train markers
                amtrakMarkers.forEach((marker, trainId) => {
                    if (marker && marker.remove) marker.remove();
                });
            } else if (category === 'seasonal') {
                // Clear seasonal rail train markers
                trainMarkers.forEach((marker, trainId) => {
                    if (marker && marker.routeName && seasonalLines.includes(marker.routeName)) {
                        if (marker.remove) marker.remove();
                    }
                });
            } else if (category === 'bus') {
                // Clear bus markers
                busMarkers.forEach((marker, busId) => {
                    if (marker && marker.remove) marker.remove();
                });
            }
            
            // Check if any categories are still checked for live tracking
            const hasSubway = document.getElementById('show-subway-live').checked;
            const hasCommuter = document.getElementById('show-commuter-live').checked;
            const hasSeasonal = document.getElementById('show-seasonal-live').checked;
            const hasBus = document.getElementById('show-bus-live').checked;
            const hasFerry = document.getElementById('show-ferry-live').checked;
            const hasAmtrak = document.getElementById('show-amtrak-live').checked;
            
            // If no categories are checked, stop all live tracking
            if (!hasSubway && !hasCommuter && !hasSeasonal && !hasBus && !hasFerry && !hasAmtrak) {
                stopLiveTracking();
            }
        }
        
        // Stop live tracking
        function stopLiveTracking() {
            if (trackingInterval) {
                clearInterval(trackingInterval);
                trackingInterval = null;
            }
            if (amtrakTrackingInterval) {
                clearInterval(amtrakTrackingInterval);
                amtrakTrackingInterval = null;
            }
            if (busTrackingInterval) {
                clearInterval(busTrackingInterval);
                busTrackingInterval = null;
            }
            
            // Clear all train markers
            trainMarkers.forEach((marker, trainId) => {
                if (marker && marker.remove) {
                    marker.remove();
                }
            });
            trainMarkers.clear();
            
            // Clear all bus markers
            busMarkers.forEach((marker, busId) => {
                if (marker && marker.remove) {
                    marker.remove();
                }
            });
            busMarkers.clear();
            
            // Clear all Amtrak markers (if any are added in the future)
            amtrakMarkers.forEach((marker, amtrakId) => {
                if (marker && marker.remove) {
                    marker.remove();
                }
            });
            amtrakMarkers.clear();
        }
        

        

        

        
        // Initially show layers based on checkbox states
        if (mbtaStopsData && typeof mbtaStopsData === 'object') {
            Object.keys(mbtaStopsData).forEach(lineName => {
                if (layers[lineName]) {
                    // Check if this line should be shown based on checkbox states
                    let shouldShow = false;
                    
                    if (subwayLines.includes(lineName) && document.getElementById('show-subway-paths').checked) {
                        shouldShow = true;
                    } else if (commuterLines.includes(lineName) && document.getElementById('show-commuter-paths').checked) {
                        shouldShow = true;
                    } else if (seasonalLines.includes(lineName) && document.getElementById('show-seasonal-paths').checked) {
                        shouldShow = true;
                    }
                    
                    if (shouldShow) {
                        map.addLayer(layers[lineName]);
                    }
                }
            });
        }
        
        // Don't show bus layers by default since checkbox is unchecked
        // Bus layers will be shown when checkbox is checked
        if (mbtaBusData && typeof mbtaBusData === 'object') {
            // Store bus layers but don't add them to map yet
            Object.keys(mbtaBusData).forEach(lineName => {
                if (layers[lineName]) {
                    // Don't add to map - wait for checkbox to be checked
                }
            });
        }
        
        if (mbtaFerryData && typeof mbtaFerryData === 'object') {
            Object.keys(mbtaFerryData).forEach(lineName => {
                if (layers[lineName]) {
                    if (document.getElementById('show-ferry-paths').checked) {
                        map.addLayer(layers[lineName]);
                    }
                }
            });
        }
        
        // Load Amtrak data if checkbox is checked by default
        if (document.getElementById('show-amtrak-paths').checked) {
            setTimeout(() => {
                loadAmtrakRoutes();
                loadAmtrakStations();
            }, 1000);
        }
        
        // Start tracking after a short delay to let the map load
        setTimeout(() => {
            startLiveTracking();
        }, 2000);
        
    </script>
</body>
</html>
