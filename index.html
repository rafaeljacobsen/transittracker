<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MBTA Tracker</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    
    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    
    <!-- Polyline decoder for encoded polylines -->
    <script src="https://unpkg.com/polyline@0.2.0/src/polyline.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        
        #map {
            height: 100vh;
            width: 100%;
        }
        
        .info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            z-index: 1000;
            width: 180px;
            max-height: none;
            overflow: hidden;
        }
        
        .info-panel h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 18px;
        }
        
        .info-panel p {
            margin: 8px 0;
            font-size: 14px;
        }
        
        .coordinates {
            font-family: monospace;
            background: #f5f5f5;
            padding: 8px;
            border-radius: 4px;
            margin: 8px 0;
            font-size: 12px;
        }
        
        .filter-controls {
            margin: 8px 0;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        
        .filter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 0 0 10px 0;
        }
        
        .filter-controls h4 {
            margin: 0;
            font-size: 14px;
            color: #555;
        }
        
        .lines-toggle {
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            width: 24px;
            height: 24px;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .lines-toggle:hover {
            background: #0056b3;
        }
        
        .lines-toggle.collapsed {
            transform: rotate(180deg);
        }
        
        .category-filters {
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .category-filters.collapsed {
            max-height: 0;
            opacity: 0;
            margin: 0;
            padding: 0;
        }
        
        .filter-checkbox {
            margin: 4px 0;
            font-size: 13px;
            display: flex;
            align-items: center;
            height: 20px;
        }
        
        .filter-checkbox input {
            margin-right: 8px;
            margin: 0;
        }
        
        .filter-checkbox label {
            margin: 0;
            line-height: 1;
        }
        
        .stats {
            background: #e9ecef;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            font-size: 12px;
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px 6px 10px;
            border-bottom: 1px solid #eee;
            background: #f8f9fa;
            border-radius: 8px 8px 0 0;
        }
        
        .panel-header h3, .panel-header h4 {
            margin: 0;
            color: #333;
        }
        
        .panel-toggle {
            position: absolute;
            right: -30px;
            top: 50%;
            transform: translateY(-50%);
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 0 8px 8px 0;
            width: 30px;
            height: 60px;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 1001;
            box-shadow: 4px 0 10px rgba(0,0,0,0.4);
        }
        
        .panel-toggle:hover {
            background: #0056b3;
            width: 25px;
        }
        
        .panel-content {
            padding: 10px;
            max-height: none;
            overflow-y: visible;
        }
        
        .panel-hidden {
            transform: translateX(-100%);
        }
        
        .panel-hidden .panel-toggle {
            right: -20px;
            background: #666;
        }
        
        .info-panel {
            transition: transform 0.3s ease;
        }
        
        .search-box {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            z-index: 1000;
            width: 250px;
        }
        
        .search-box input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .search-results {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }
        
        .search-result {
            padding: 8px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            font-size: 13px;
        }
        
        .search-result:hover {
            background: #f5f5f5;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="info-panel" id="info-panel">
        <button class="panel-toggle" onclick="togglePanel('info-panel')">◀</button>

        
        <div class="panel-content">
            <div class="filter-controls">
                <div class="filter-header">
                    <h4>Show/Hide Lines:</h4>
                    <button class="lines-toggle" onclick="toggleLinesSection()" title="Hide/Show Lines Section">−</button>
                </div>
                
                <!-- Service controls with Paths and Live columns -->
                <div class="category-filters" id="lines-section">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr>
                                <th style="text-align: left; padding: 5px; font-size: 12px;">Service</th>
                                <th style="text-align: center; padding: 5px; font-size: 12px;">Paths</th>
                                <th style="text-align: center; padding: 5px; font-size: 12px;">Live</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td style="padding: 5px; font-size: 12px;">Subway</td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-subway-paths" checked>
                                </td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-subway-live" checked>
                                </td>
                            </tr>
                            <tr>
                                <td style="padding: 5px; font-size: 12px;">Commuter Rail</td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-commuter-paths" checked>
                                </td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-commuter-live" checked>
                                </td>
                            </tr>
                            <tr>
                                <td style="padding: 5px; font-size: 12px;">Seasonal Rail</td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-seasonal-paths" checked>
                                </td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-seasonal-live" checked>
                                </td>
                            </tr>
                            <tr>
                                <td style="padding: 5px; font-size: 12px;">Bus</td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-bus-paths">
                                </td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-bus-live">
                                </td>
                            </tr>
                            <tr>
                                <td style="padding: 5px; font-size: 12px;">Ferry</td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-ferry-paths" checked>
                                </td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-ferry-live" checked>
                                </td>
                            </tr>
                            <tr>
                                <td style="padding: 5px; font-size: 12px;">Amtrak</td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-amtrak-paths" checked>
                                </td>
                                <td style="text-align: center; padding: 5px;">
                                    <input type="checkbox" id="show-amtrak-live" checked>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
    

    

    


    <!-- Include the MBTA stops data -->
    <script src="mbta-stops-accurate.js"></script>
    
    <!-- Include the MBTA bus data -->
            <script src="mbta-bus-data.js"></script>
    
    <!-- Include the MBTA ferry data -->
    <script src="mbta-ferry-data.js"></script>

    <script>
        // Global variables - declare these first
        const trainMarkers = new Map();
        const ferryMarkers = new Map();
        const amtrakMarkers = new Map();
        const busMarkers = new Map();
        let trackingInterval;
        let ferryTrackingInterval;
        let amtrakTrackingInterval;
        let busTrackingInterval;
        let lastUpdateTime = 0;
        let lastFerryUpdateTime = 0;
        let lastAmtrakUpdateTime = 0;
        let lastBusUpdateTime = 0;
        
        // Check if data is ready before proceeding
        if (typeof mbtaStopsData === 'undefined' || !mbtaStopsData) {
            document.getElementById('map').innerHTML = '<div style="text-align: center; padding: 50px; font-size: 18px; color: #666;">Loading MBTA data...</div>';
            // Don't run any more code
            throw new Error('MBTA data not loaded');
        }
        
        // Initialize the map centered on Boston
        const map = L.map('map').setView([42.3601, -71.0589], 11);
        
        // Add OpenStreetMap tiles
        const osmTiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            maxZoom: 19
        });
        
        osmTiles.addTo(map);
        
        // Create layer groups for each transit line
        const layers = {};
        
        // Initialize layers for all lines
        if (mbtaStopsData && typeof mbtaStopsData === 'object') {
            try {
                Object.keys(mbtaStopsData).forEach(lineName => {
                    layers[lineName] = L.layerGroup();
                    // Don't add to map yet - wait for checkbox
                });
            } catch (e) {
                // Silently handle any errors
            }
        }
        
        // Initialize layers for bus routes
        if (mbtaBusData && typeof mbtaBusData === 'object') {
            try {
                Object.keys(mbtaBusData).forEach(lineName => {
                    layers[lineName] = L.layerGroup();
                    // Don't add to map yet - wait for checkbox
                });
            } catch (e) {
                // Silently handle any errors
            }
        }
        
        // Initialize layers for ferry routes
        if (mbtaFerryData && typeof mbtaFerryData === 'object') {
            try {
                Object.keys(mbtaFerryData).forEach(lineName => {
                    layers[lineName] = L.layerGroup();
                    map.addLayer(layers[lineName]);
                });
            } catch (e) {
                // Silently handle any errors
            }
        }
        
        // Generate filter checkboxes dynamically
        const filterContainer = document.getElementById('filter-checkboxes');
        
        // Define subway, commuter rail, seasonal rail, and bus lines
        const subwayLines = ['Red Line', 'Orange Line', 'Blue Line', 'Green Line B', 'Green Line C', 'Green Line D', 'Green Line E', 'Mattapan Trolley'];
        const commuterLines = ['Fairmount Line', 'Fall River/New Bedford Line', 'Fitchburg Line', 'Framingham/Worcester Line', 'Franklin/Foxboro Line', 'Greenbush Line', 'Haverhill Line', 'Kingston Line', 'Lowell Line', 'Needham Line', 'Newburyport/Rockport Line', 'Providence/Stoughton Line', 'Foxboro Event Service'];
        const seasonalLines = ['CapeFLYER'];
        const busLines = ['1', '4', '7', '8', '9', '10', '11', '14', '15', '16', '17', '18', '19', '21', '22', '23', '24', '26', '28', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '40', '41', '42', '43', '44', '45', '47', '50', '51', '52', '55', '57', '59', '60', '61', '62', '64', '65', '66', '67', '68', '69', '70', '71', '73', '74', '75', '76', '77', '78', '80', '83', '85', '86', '87', '88', '89', '90', '91', '92', '93', '94', '95', '96', '97', '99', '100', '101', '104', '105', '106', '108', '109', '110', '111', '112', '114', '116', '119', '120', '121', '131', '132', '134', '137', '171', '201', '202', '210', '211', '215', '216', '217', '220', '222', '225', '226', '230', '236', '238', '240', '245', '350', '351', '411', '424', '428', '430', '435', '436', '439', '441', '442', '450', '451', '455', '456', '501', '504', '505', '553', '554', '556', '558', '627', '708', '712', '713', '714', '716', '741', '742', '743', '746', '747', '749', '751'];
        const ferryLines = ['Boat-F4', 'Boat-F1', 'Boat-EastBoston', 'Boat-Lynn', 'Boat-F6', 'Boat-F7', 'Boat-F8'];
        const amtrakLines = ['Amtrak']; // Will be populated with actual route names from API

        
        // Add event listeners for category filters
        // Subway paths filter
        document.getElementById('show-subway-paths').addEventListener('change', function() {
            const isChecked = this.checked;
            subwayLines.forEach(lineName => {
                if (mbtaStopsData[lineName] && layers[lineName]) {
                    if (isChecked) {
                        map.addLayer(layers[lineName]);
                    } else {
                        map.removeLayer(layers[lineName]);
                    }
                }
            });
            updateStats();
        });
        
        // Subway live tracking filter
        document.getElementById('show-subway-live').addEventListener('change', function() {
            const isChecked = this.checked;
            
            // Hide/show train markers for subway lines ONLY
            trainMarkers.forEach((marker, trainId) => {
                if (marker && marker.routeName) {
                    if (subwayLines.includes(marker.routeName)) {
                        if (isChecked) {
                            marker.addTo(map);
                        } else {
                            marker.remove();
                        }
                    }
                }
            });
            
            // Control live tracking for subway lines
            if (isChecked) {
                // Resume live tracking if it was stopped
                if (!trackingInterval) {
                    startLiveTracking();
                }
            } else {
                // Check if any other services are still active for live tracking
                const hasCommuter = document.getElementById('show-commuter-live').checked;
                const hasSeasonal = document.getElementById('show-seasonal-live').checked;
                const hasBus = document.getElementById('show-bus-live').checked;
                const hasFerry = document.getElementById('show-ferry-live').checked;
                const hasAmtrak = document.getElementById('show-amtrak-live').checked;
                
                // If no categories are checked, stop live tracking
                if (!hasCommuter && !hasSeasonal && !hasBus && !hasFerry && !hasAmtrak) {
                    stopLiveTracking();
                }
            }
            
            updateStats();
        });
        
        // Commuter rail paths filter
        document.getElementById('show-commuter-paths').addEventListener('change', function() {
            const isChecked = this.checked;
            commuterLines.forEach(lineName => {
                if (mbtaStopsData[lineName] && layers[lineName]) {
                    if (isChecked) {
                        map.addLayer(layers[lineName]);
                    } else {
                        map.removeLayer(layers[lineName]);
                    }
                }
            });
            updateStats();
        });
        
        // Commuter rail live tracking filter
        document.getElementById('show-commuter-live').addEventListener('change', function() {
            const isChecked = this.checked;
            
            // Hide/show train markers for commuter rail lines ONLY
            trainMarkers.forEach((marker, trainId) => {
                if (marker && marker.routeName) {
                    if (commuterLines.includes(marker.routeName)) {
                        if (isChecked) {
                            marker.addTo(map);
                        } else {
                            marker.remove();
                        }
                    }
                }
            });
            
            // Control live tracking for commuter rail lines
            if (isChecked) {
                // Resume live tracking if it was stopped
                if (!trackingInterval) {
                    startLiveTracking();
                }
            } else {
                // Check if any other services are still active for live tracking
                const hasSubway = document.getElementById('show-subway-live').checked;
                const hasSeasonal = document.getElementById('show-seasonal-live').checked;
                const hasBus = document.getElementById('show-bus-live').checked;
                const hasFerry = document.getElementById('show-ferry-live').checked;
                const hasAmtrak = document.getElementById('show-amtrak-live').checked;
                
                // If no categories are checked, stop live tracking
                if (!hasSubway && !hasSeasonal && !hasBus && !hasFerry && !hasAmtrak) {
                    stopLiveTracking();
                }
            }
            
            updateStats();
        });
        
        // Seasonal rail paths filter
        document.getElementById('show-seasonal-paths').addEventListener('change', function() {
            const isChecked = this.checked;
            seasonalLines.forEach(lineName => {
                if (mbtaStopsData[lineName] && layers[lineName]) {
                    if (isChecked) {
                        map.addLayer(layers[lineName]);
                    } else {
                        map.removeLayer(layers[lineName]);
                    }
                }
            });
            updateStats();
        });
        
        // Seasonal rail live tracking filter
        document.getElementById('show-seasonal-live').addEventListener('change', function() {
            const isChecked = this.checked;
            
            // Hide/show train markers for seasonal rail lines ONLY
            trainMarkers.forEach((marker, trainId) => {
                if (marker && marker.routeName) {
                    if (seasonalLines.includes(marker.routeName)) {
                        if (isChecked) {
                            marker.addTo(map);
                        } else {
                            marker.remove();
                        }
                    }
                }
            });
            
            // Control live tracking for seasonal rail lines
            if (isChecked) {
                // Resume live tracking if it was stopped
                if (!trackingInterval) {
                    startLiveTracking();
                }
            } else {
                // Check if any other services are still active for live tracking
                const hasSubway = document.getElementById('show-subway-live').checked;
                const hasCommuter = document.getElementById('show-commuter-live').checked;
                const hasBus = document.getElementById('show-bus-live').checked;
                const hasFerry = document.getElementById('show-ferry-live').checked;
                const hasAmtrak = document.getElementById('show-amtrak-live').checked;
                
                // If no categories are checked, stop live tracking
                if (!hasSubway && !hasCommuter && !hasBus && !hasFerry && !hasAmtrak) {
                    stopLiveTracking();
                }
            }
            
            updateStats();
        });
        
        // Bus paths filter
        document.getElementById('show-bus-paths').addEventListener('change', function() {
            const isChecked = this.checked;
            // Use all available bus routes from mbtaBusData instead of just busLines
            if (mbtaBusData && typeof mbtaBusData === 'object') {
                Object.keys(mbtaBusData).forEach(lineName => {
                    if (layers[lineName]) {
                        if (isChecked) {
                            map.addLayer(layers[lineName]);
                        } else {
                            map.removeLayer(layers[lineName]);
                        }
                    }
                });
            }
            updateStats();
        });
        
        // Bus live tracking filter
        document.getElementById('show-bus-live').addEventListener('change', function() {
            const isChecked = this.checked;
            
            // Hide/show bus markers
            busMarkers.forEach((marker, busId) => {
                if (marker) {
                    if (isChecked) {
                        marker.addTo(map);
                    } else {
                        marker.remove();
                    }
                }
            });
            
            // Control live tracking for bus routes
            if (isChecked) {
                // Resume live tracking if it was stopped
                if (!trackingInterval) {
                    startLiveTracking();
                }
            } else {
                // Check if any other services are still active for live tracking
                const hasSubway = document.getElementById('show-subway-live').checked;
                const hasCommuter = document.getElementById('show-commuter-live').checked;
                const hasSeasonal = document.getElementById('show-seasonal-live').checked;
                const hasFerry = document.getElementById('show-ferry-live').checked;
                const hasAmtrak = document.getElementById('show-amtrak-live').checked;
                
                // If no categories are checked, stop live tracking
                if (!hasSubway && !hasCommuter && !hasSeasonal && !hasFerry && !hasAmtrak) {
                    stopLiveTracking();
                }
            }
            
            updateStats();
        });
        
        // Ferry paths filter
        document.getElementById('show-ferry-paths').addEventListener('change', function() {
            const isChecked = this.checked;
            ferryLines.forEach(lineName => {
                if (mbtaFerryData[lineName] && layers[lineName]) {
                    if (isChecked) {
                        map.addLayer(layers[lineName]);
                    } else {
                        map.removeLayer(layers[lineName]);
                    }
                }
            });
            updateStats();
        });
        
        // Ferry live tracking filter
        document.getElementById('show-ferry-live').addEventListener('change', function() {
            const isChecked = this.checked;
            
            // Hide/show ferry markers
            ferryMarkers.forEach((marker, ferryId) => {
                if (marker) {
                    if (isChecked) {
                        marker.addTo(map);
                    } else {
                        marker.remove();
                    }
                }
            });
            
            // Control live tracking for ferry routes
            if (isChecked) {
                // Resume live tracking if it was stopped
                if (!trackingInterval) {
                    startLiveTracking();
                }
            } else {
                // Check if any other services are still active for live tracking
                const hasSubway = document.getElementById('show-subway-live').checked;
                const hasCommuter = document.getElementById('show-commuter-live').checked;
                const hasSeasonal = document.getElementById('show-seasonal-live').checked;
                const hasBus = document.getElementById('show-bus-live').checked;
                const hasAmtrak = document.getElementById('show-amtrak-live').checked;
                
                // If no categories are checked, stop live tracking
                if (!hasSubway && !hasCommuter && !hasSeasonal && !hasBus && !hasAmtrak) {
                    stopLiveTracking();
                }
            }
            
            updateStats();
        });
        
        // Amtrak paths filter
        document.getElementById('show-amtrak-paths').addEventListener('change', function() {
            const isChecked = this.checked;
            
            if (isChecked) {
                // Load Amtrak routes if not already loaded
                if (!window.amtrakRoutesLoaded) {
                    loadAmtrakRoutes();
                }
                
                // Load Amtrak stations
                loadAmtrakStations();
                
                // Show Amtrak routes
                if (window.amtrakRouteLayers) {
                    Object.values(window.amtrakRouteLayers).forEach(layer => {
                        if (layer) map.addLayer(layer);
                    });
                }
                
                // Show Amtrak station markers
                if (window.amtrakStationMarkers) {
                    window.amtrakStationMarkers.forEach(marker => {
                        if (marker) marker.addTo(map);
                    });
                }
            } else {
                // Hide Amtrak routes
                if (window.amtrakRouteLayers) {
                    Object.values(window.amtrakRouteLayers).forEach(layer => {
                        if (layer) map.removeLayer(layer);
                    });
                }
                
                // Hide Amtrak station markers
                if (window.amtrakStationMarkers) {
                    window.amtrakStationMarkers.forEach(marker => {
                        if (marker) marker.remove();
                    });
                }
            }
            
            updateStats();
        });
        
        // Amtrak live tracking filter
        document.getElementById('show-amtrak-live').addEventListener('change', function() {
            const isChecked = this.checked;
            
            // Hide/show existing Amtrak train markers
            if (amtrakMarkers) {
                amtrakMarkers.forEach(marker => {
                    if (marker) {
                        if (isChecked) {
                            marker.addTo(map);
                        } else {
                            marker.remove();
                        }
                    }
                });
            }
            
            // Control live tracking for Amtrak
            if (isChecked) {
                // Resume live tracking if it was stopped
                if (!trackingInterval) {
                    startLiveTracking();
                }
            } else {
                // Check if any other services are still active for live tracking
                const hasSubway = document.getElementById('show-subway-live').checked;
                const hasCommuter = document.getElementById('show-commuter-live').checked;
                const hasSeasonal = document.getElementById('show-seasonal-live').checked;
                const hasBus = document.getElementById('show-bus-live').checked;
                const hasFerry = document.getElementById('show-ferry-live').checked;
                
                // If no categories are checked, stop live tracking
                if (!hasSubway && !hasCommuter && !hasSeasonal && !hasBus && !hasFerry) {
                    stopLiveTracking();
                }
            }
            
            updateStats();
        });
        // Color scheme for different lines
        const lineColors = {
            'Red Line': '#DA291C',
            'Orange Line': '#FF6600',
            'Blue Line': '#003DA5',
            'Green Line B': '#00843D',
            'Green Line C': '#00843D',
            'Green Line D': '#00843D',
            'Green Line E': '#00843D',
            'Mattapan Trolley': '#DA291C',
            'Fairmount Line': '#800080',
            'Fall River/New Bedford Line': '#800080',
            'Fitchburg Line': '#800080',
            'Foxboro Event Service': '#800080',
            'Framingham/Worcester Line': '#800080',
            'Franklin/Foxboro Line': '#800080',
            'Greenbush Line': '#800080',
            'Haverhill Line': '#800080',
            'Kingston Line': '#800080',
            'Lowell Line': '#800080',
            'Needham Line': '#800080',
            'Newburyport/Rockport Line': '#800080',
            'Providence/Stoughton Line': '#800080',
            // Bus routes - all yellow
            '71': '#FFD700',
            '73': '#FFD700',
            // Ferry routes - all blue
            'Boat-F4': '#008EAA',
            'Boat-F1': '#008EAA',
            'Boat-EastBoston': '#008EAA',
            'Boat-Lynn': '#008EAA',
            'Boat-F6': '#008EAA',
            'Boat-F7': '#008EAA',
            'Boat-F8': '#008EAA',
            // Amtrak routes - use distinct colors
            'Amtrak': '#1E3A8A',
            'Northeast Corridor': '#DC2626',
            'Acela': '#7C2D12',
            'Vermonter': '#059669',
            'Downeaster': '#7C3AED',
            'Lake Shore Limited': '#EA580C',
            'Empire Service': '#BE185D'
        };

        
                    // Create markers and tracks for all routes
            const markers = [];
            const stopMarkers = new Map(); // Track markers by stopId for multi-line stops
            
            if (typeof mbtaStopsData !== 'undefined' && typeof routeShapes !== 'undefined') {
                
                let totalTracksDrawn = 0;
                let totalStopsDrawn = 0;
                
                // Batch processing for better performance
                const processRoute = (lineName, stops, color) => {
                    const routeMarkers = [];
                    const routeTracks = [];
                    
                    // Process track shapes
                    if (routeShapes[lineName] && routeShapes[lineName].length > 0) {
                        routeShapes[lineName].forEach((shape, shapeIndex) => {
                            if (shape.coords && shape.coords.length > 1) {
                                // Optimized duplicate coordinate removal
                                const cleanCoords = [];
                                let prevLat = null, prevLon = null;
                                
                                for (let i = 0; i < shape.coords.length; i++) {
                                    const coord = shape.coords[i];
                                    if (prevLat !== coord[0] || prevLon !== coord[1]) {
                                        cleanCoords.push(coord);
                                        prevLat = coord[0];
                                        prevLon = coord[1];
                                    }
                                }
                                
                                if (cleanCoords.length > 1) {
                                    const trackLine = L.polyline(cleanCoords, {
                                        color: color,
                                        weight: 3,
                                        opacity: 0.7
                                    });
                                    
                                    trackLine.bindPopup(`<b>${lineName}</b> Shape ${shapeIndex + 1} Track`);
                                    routeTracks.push(trackLine);
                                    totalTracksDrawn++;
                                }
                            }
                        });
                    }
                    
                    // Process stop markers
                    stops.forEach(stop => {
                        const stopRoutes = stopToRoutes[stop.stopId] || [];
                        const isMultiLine = stopRoutes.length > 1;
                        
                        if (isMultiLine && stopMarkers.has(stop.stopId)) {
                            const existingMarker = stopMarkers.get(stop.stopId);
                            existingMarker.options.colors = existingMarker.options.colors || [];
                            existingMarker.options.colors.push(color);
                            
                            const allLines = stopRoutes.join(', ');
                            existingMarker.bindPopup(`
                                <b>${stop.name}</b><br>
                                Type: ${stop.type}<br>
                                Lines: ${allLines}<br>
                                Coordinates: ${stop.coords[0].toFixed(6)}, ${stop.coords[1].toFixed(6)}
                            `);
                        } else {
                            const marker = L.circleMarker(stop.coords, {
                                radius: isMultiLine ? 8 : 6,
                                fillColor: color,
                                color: '#fff',
                                weight: 2,
                                opacity: 1,
                                fillOpacity: 0.8,
                                colors: isMultiLine ? [color] : undefined
                            });
                            
                            const popupText = isMultiLine ? 
                                `<b>${stop.name}</b><br>Type: ${stop.type}<br>Lines: ${stopRoutes.join(', ')}<br>Coordinates: ${stop.coords[0].toFixed(6)}, ${stop.coords[1].toFixed(6)}` :
                                `<b>${stop.name}</b><br>Type: ${stop.type}<br>Line: ${lineName}<br>Coordinates: ${stop.coords[0].toFixed(6)}, ${stop.coords[1].toFixed(6)}`;
                            
                            marker.bindPopup(popupText);
                            routeMarkers.push(marker);
                            totalStopsDrawn++;
                            
                            if (isMultiLine) {
                                stopMarkers.set(stop.stopId, marker);
                            }
                        }
                    });
                    
                    return { markers: routeMarkers, tracks: routeTracks };
                };
                
                // Process routes in chunks to prevent UI freezing
                const routes = Object.entries(mbtaStopsData);
                const chunkSize = 5; // Process 5 routes at a time
                
                const processChunk = (startIndex) => {
                    const endIndex = Math.min(startIndex + chunkSize, routes.length);
                    const chunk = routes.slice(startIndex, endIndex);
                    
                    chunk.forEach(([lineName, stops]) => {
                        const color = lineColors[lineName] || '#666';
                        const result = processRoute(lineName, stops, color);
                        
                        // Batch add markers and tracks to layers
                        result.markers.forEach(marker => {
                            markers.push(marker);
                            layers[lineName].addLayer(marker);
                        });
                        
                        result.tracks.forEach(track => {
                            markers.push(track);
                            layers[lineName].addLayer(track);
                        });
                    });
                    
                    // Process next chunk if there are more routes
                    if (endIndex < routes.length) {
                        setTimeout(() => processChunk(endIndex), 10); // 10ms delay between chunks
                    } else {
        
                    }
                };
                
                // Start processing
                processChunk(0);
                
            } else {
                console.error('Cannot create markers: mbtaStopsData or routeShapes is undefined');
            }
            
            // Create bus route markers and tracks
            if (mbtaBusData) {
                Object.keys(mbtaBusData).forEach(lineName => {
                    // Only process routes that are actually buses (route_type 3)
                    // Skip subway/commuter rail routes that are in mbtaStopsData
                    if (mbtaStopsData && mbtaStopsData[lineName]) {
                        return; // Skip this route - it's subway/commuter rail
                    }
                    
                    // Create the layer for this bus route
                    layers[lineName] = L.layerGroup();
                    
                    const stops = mbtaBusData[lineName]; // stops is now the array directly
                    const color = lineColors[lineName] || '#FFD700';
                    const routeMarkers = [];
                    const routeTracks = [];
                    
                    // Process bus route shapes
                    if (busRouteShapes[lineName] && busRouteShapes[lineName].length > 0) {
                        busRouteShapes[lineName].forEach((shape, shapeIndex) => {
                            if (shape.polyline) {
                                // Decode the encoded polyline from the API
                                const coords = polyline.decode(shape.polyline);
                                if (coords && coords.length > 1) {
            
                                    const trackLine = L.polyline(coords, {
                                        color: color,
                                        weight: 2,
                                        opacity: 0.6
                                    });
                                    
                                    trackLine.bindPopup(`<b>Bus Route ${lineName}</b> Shape ${shapeIndex + 1}`);
                                    routeTracks.push(trackLine);
                                }
                            }
                        });
                    }
                    
                    // Process bus stop markers
                    if (stops && Array.isArray(stops)) {
                        stops.forEach(stop => {
                            const marker = L.circleMarker(stop.coords, {
                                radius: 2,
                                fillColor: color,
                                color: '#fff',
                                weight: 1,
                                opacity: 1,
                                fillOpacity: 0.8
                            });
                            
                            marker.bindPopup(`
                                <b>${stop.name}</b><br>
                                Type: ${stop.type}<br>
                                Route: ${lineName}<br>
                                Coordinates: ${stop.coords[0].toFixed(6)}, ${stop.coords[1].toFixed(6)}
                            `);
                            
                            routeMarkers.push(marker);
                        });
                    }
                    
                    // Add markers and tracks to layers
                    
                    routeMarkers.forEach(marker => {
                        layers[lineName].addLayer(marker);
                    });
                    
                    routeTracks.forEach(track => {
                        layers[lineName].addLayer(track);
                    });
                    
                    // Add the layer to the map only if bus paths checkbox is checked
                    if (document.getElementById('show-bus-paths').checked) {
                        layers[lineName].addTo(map);
                    }
                });
            }
            
            // Create ferry route markers and tracks
            if (mbtaFerryData && ferryRouteShapes) {
                Object.keys(mbtaFerryData).forEach(lineName => {
                    const stops = mbtaFerryData[lineName];
                    const color = '#008EAA'; // Ferry blue color
                    const routeMarkers = [];
                    const routeTracks = [];
                    
                    // Process ferry route shapes
                    if (ferryRouteShapes[lineName] && ferryRouteShapes[lineName].length > 0) {
                        ferryRouteShapes[lineName].forEach((shape, shapeIndex) => {
                            if (shape.coords && shape.coords.length > 1) {
                                const trackLine = L.polyline(shape.coords, {
                                    color: color,
                                    weight: 3,
                                    opacity: 0.8
                                });
                                
                                trackLine.bindPopup(`<b>Ferry Route ${lineName}</b> Shape ${shapeIndex + 1}`);
                                routeTracks.push(trackLine);
                            }
                        });
                    }
                    
                    // Process ferry stop markers
                    stops.forEach(stop => {
                        const marker = L.circleMarker(stop.coords, {
                            radius: 6,
                            fillColor: color,
                            color: '#fff',
                            weight: 2,
                            opacity: 1,
                            fillOpacity: 0.9
                        });
                        
                        marker.bindPopup(`
                            <b>${stop.name}</b><br>
                            Type: ${stop.type}<br>
                            Route: ${lineName}<br>
                            Coordinates: ${stop.coords[0].toFixed(6)}, ${stop.coords[1].toFixed(6)}
                        `);
                        
                        routeMarkers.push(marker);
                    });
                    
                    // Add markers and tracks to layers
                    routeMarkers.forEach(marker => {
                        layers[lineName].addLayer(marker);
                    });
                    
                    routeTracks.forEach(track => {
                        layers[lineName].addLayer(track);
                    });
                });
            }
        
        // Update stats display (no-op since stats were removed)
        function updateStats() {
            // Stats display was removed - function kept for compatibility
        }
        

        

        
        // Filter controls are now generated dynamically above
        

        
        // Panel toggle functionality
        function togglePanel(panelId) {
            const panel = document.getElementById(panelId);
            const toggle = panel.querySelector('.panel-toggle');
            
            if (panel.classList.contains('panel-hidden')) {
                // Show panel
                panel.classList.remove('panel-hidden');
                toggle.textContent = '◀';
            } else {
                // Hide panel
                panel.classList.add('panel-hidden');
                toggle.textContent = '▶';
            }
        }
        
        // Lines section toggle functionality
        function toggleLinesSection() {
            const linesSection = document.getElementById('lines-section');
            const toggle = document.querySelector('.lines-toggle');
            
            if (linesSection.classList.contains('collapsed')) {
                // Show lines section
                linesSection.classList.remove('collapsed');
                toggle.textContent = '−';
                toggle.classList.remove('collapsed');
            } else {
                // Hide lines section
                linesSection.classList.add('collapsed');
                toggle.textContent = '+';
                toggle.classList.add('collapsed');
            }
        }
        
        // Initialize stats
        updateStats();
        
        // Add scale control
        const scaleControl = L.control.scale({
            position: 'bottomleft'
        }).addTo(map);
        

        

        
        // Live MBTA Train Tracking
        

        
        // Function to fetch live train positions
        async function fetchLiveTrains() {
            try {
                const now = Date.now();
                if (now - lastUpdateTime < 5000) { // Rate limit: 5 seconds
                    return;
                }
                
                const response = await fetch('https://api-v3.mbta.com/vehicles?filter[route_type]=0,1,2&include=route');
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                lastUpdateTime = now;
                
                if (data.data && data.data.length > 0) {
                    updateTrainMarkers(data.data);
                }
                
            } catch (error) {
                console.error('Error fetching MBTA trains:', error);
            }
        }
        
        // Function to fetch live bus positions
        async function fetchLiveBuses() {
            try {
                const now = Date.now();
                if (now - lastBusUpdateTime < 5000) { // Rate limit: 5 seconds
                    return;
                }
                
                const response = await fetch('https://api-v3.mbta.com/vehicles?filter[route_type]=3&include=route');
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                lastBusUpdateTime = now;
                
                if (data.data && data.data.length > 0) {
                    updateBusMarkers(data.data);
                }
                
            } catch (error) {
                console.error('Error fetching MBTA buses:', error);
            }
        }
        
        // Function to fetch live ferry positions
        async function fetchLiveFerries() {
            try {
                const now = Date.now();
                if (now - lastUpdateTime < 5000) { // Rate limit: 5 seconds
                    return;
                }
                
                const response = await fetch('https://api-v3.mbta.com/vehicles?filter[route_type]=4&include=route');
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                lastUpdateTime = now;
                
                if (data.data && data.data.length > 0) {
                    updateFerryMarkers(data.data);
                }
                
            } catch (error) {
                console.error('Error fetching MBTA ferries:', error);
            }
        }
        
        // Amtrak V3 API Client for Live Train Tracking
        class AmtrakV3Client {
            constructor(baseUrl = "https://api-v3.amtraker.com", timeout = 20000) {
                this.baseUrl = baseUrl.replace(/\/$/, "");
                this.timeout = timeout;
                this.session = new Map(); // Simple session cache
            }

            // Internal helper for making requests
            async _get(path, params = null) {
                const url = `${this.baseUrl}/${path.replace(/^\//, '')}`;
                const urlWithParams = params ? `${url}?${new URLSearchParams(params)}` : url;
                
                try {
                    const response = await fetch(urlWithParams, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json'
                        },
                        signal: AbortSignal.timeout(this.timeout)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    return await response.json();
                } catch (error) {
                    console.error(`Error fetching ${urlWithParams}:`, error);
                    throw error;
                }
            }

            // Get all active trains
            async getAllTrains() {
                return await this._get("v3/trains");
            }

            // Get specific train by number or trainId
            async getTrain(trainIdOrNum) {
                return await this._get(`v3/trains/${trainIdOrNum}`);
            }

            // Get all station metadata
            async getAllStations() {
                return await this._get("v3/stations");
            }

            // Get specific station metadata
            async getStation(stationId) {
                return await this._get(`v3/stations/${stationId}`);
            }

            // Get feed health status
            async getStaleStatus() {
                return await this._get("v3/stale");
            }

            // Flatten trains response to records
            static trainsDictToRecords(trainsByNum) {
                const rows = [];
                for (const [trainNum, items] of Object.entries(trainsByNum || {})) {
                    for (const tdata of (items || [])) {
                        if (tdata) {
                            rows.push({
                                trainNum: tdata.trainNum || trainNum,
                                trainId: tdata.trainId,
                                routeName: tdata.routeName,
                                state: tdata.trainState || tdata.state,
                                statusMsg: tdata.statusMsg,
                                lat: tdata.lat,
                                lon: tdata.lon,
                                heading: tdata.heading,
                                velocity: tdata.velocity,
                                lastValTS: tdata.lastValTS || tdata.updatedAt,
                                eventCode: tdata.eventCode,
                                origCode: tdata.origCode,
                                destCode: tdata.destCode,
                                stationsLen: Array.isArray(tdata.stations) ? tdata.stations.length : null
                            });
                        }
                    }
                }
                return rows;
            }

            // Flatten stations response to records
            static stationsDictToRecords(stationsById) {
                const out = [];
                for (const [sid, meta] of Object.entries(stationsById || {})) {
                    if (meta) {
                        out.push({
                            stationId: sid,
                            name: meta.name || meta.stationName,
                            city: meta.city,
                            state: meta.state,
                            tz: meta.tz,
                            lat: meta.lat,
                            lon: meta.lon
                        });
                    }
                }
                return out;
            }
        }

        // Global Amtrak client instance
        let amtrakClient = null;

        // Function to fetch live Amtrak train positions
        async function fetchLiveAmtrakTrains() {
            try {
                const now = Date.now();
                if (now - lastAmtrakUpdateTime < 10000) { // Rate limit: 10 seconds for Amtrak
                    return;
                }

                // Check if AmtrakV3Client class is available
                if (typeof AmtrakV3Client === 'undefined') {
    
                    return;
                }

                // Initialize Amtrak client if not already done
                if (!amtrakClient) {
                    amtrakClient = new AmtrakV3Client();
                }

                // Get all active trains
                const trainsData = await amtrakClient.getAllTrains();
                
                if (trainsData && Object.keys(trainsData).length > 0) {
                    // Convert to flat records
                    const trainRecords = AmtrakV3Client.trainsDictToRecords(trainsData);
                    
                    // Update Amtrak train markers on the map
                    updateAmtrakTrainMarkers(trainRecords);
                    
                    lastAmtrakUpdateTime = now;
                }

            } catch (error) {
                console.error('Error fetching Amtrak trains:', error);
                // Don't update lastAmtrakUpdateTime on error to allow retry
            }
                }

        // Function to update Amtrak train markers on the map
        function updateAmtrakTrainMarkers(trains) {
            // Store current popup states before clearing markers
            const currentPopups = new Map();
            amtrakMarkers.forEach((marker, trainId) => {
                if (marker && marker.isPopupOpen && marker.isPopupOpen()) {
                    currentPopups.set(trainId, marker.getPopup().getContent());
                }
            });

            // Clear old Amtrak train markers
            amtrakMarkers.forEach((marker, trainId) => {
                if (marker && marker.remove) {
                    marker.remove();
                }
            });
            amtrakMarkers.clear();

            // Create new Amtrak train markers
            trains.forEach(train => {
                if (train.lat && train.lon && !isNaN(train.lat) && !isNaN(train.lon)) {
                    const trainId = train.trainId || train.trainNum;
                    const lat = parseFloat(train.lat);
                    const lng = parseFloat(train.lon);
                    const heading = train.heading || 0;
                    const velocity = train.velocity;
                    const routeName = train.routeName || 'Amtrak';
                    const trainState = train.state;
                    const statusMsg = train.statusMsg;
                    const origCode = train.origCode;
                    const destCode = train.destCode;

                    // Get route color
                    const routeColor = getAmtrakRouteColor(routeName);

                    // Create Amtrak train marker with custom icon
                    const amtrakIcon = L.icon({
                        iconUrl: 'icons/amtrakcirc.png',
                        iconSize: [28, 28],
                        iconAnchor: [14, 14]
                    });

                    const trainMarker = L.marker([lat, lng], {
                        icon: amtrakIcon,
                        zIndexOffset: 100
                    });

                    // Create popup with train info
                    let popupContent = `
                        <div style="color: ${routeColor}; font-weight: bold;">
                            🚂 Live Amtrak Train
                        </div>
                        <b>Train:</b> ${train.trainNum || 'Unknown'}<br>
                        <b>Route:</b> ${routeName}<br>`;

                    if (origCode && destCode) {
                        popupContent += `<b>Route:</b> ${origCode} → ${destCode}<br>`;
                    }

                    if (velocity !== null && velocity !== undefined && !isNaN(velocity) && velocity > 0) {
                        popupContent += `<b>Speed:</b> ${Math.round(velocity)} mph<br>`;
                    }

                    if (trainState) {
                        popupContent += `<b>Status:</b> ${trainState}<br>`;
                    }

                    if (statusMsg && statusMsg.trim() !== '') {
                        popupContent += `<b>Message:</b> ${statusMsg}<br>`;
                    }

                    popupContent += `
                        <b>Position:</b> ${lat.toFixed(6)}, ${lng.toFixed(6)}<br>
                        <b>Last Update:</b> ${new Date().toLocaleTimeString()}`;

                    trainMarker.bindPopup(popupContent);

                    // Store route name with marker for filtering
                    trainMarker.routeName = routeName;

                    // Add to map and store reference (only if Amtrak live tracking is checked)
                    if (document.getElementById('show-amtrak-live').checked) {
                        trainMarker.addTo(map);
                    }
                    amtrakMarkers.set(trainId, trainMarker);

                    // Restore popup if it was open before
                    if (currentPopups.has(trainId)) {
                        trainMarker.openPopup();
                    }


                }
            });


        }

        // Function to load and display Amtrak stations from local file
        async function loadAmtrakStations() {
            try {
                // Load stations from local file
                const response = await fetch('amtrak-stations-data.js');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const stationsData = await response.json();
                
                if (stationsData && stationsData.stations && stationsData.stations.length > 0) {
                    createAmtrakStationMarkers(stationsData.stations);
                } else {
                    throw new Error('No stations found in local file');
                }
            } catch (error) {
                console.error('Error loading Amtrak stations from local file:', error);
                // Fallback to API if local file fails
                await loadAmtrakStationsFromAPI();
            }
        }

        // Function to create Amtrak station markers
        function createAmtrakStationMarkers(stations) {
            // Clear existing station markers if any
            if (window.amtrakStationMarkers) {
                window.amtrakStationMarkers.forEach(marker => {
                    if (marker && marker.remove) marker.remove();
                });
            }
            
            window.amtrakStationMarkers = new Map();
            
            stations.forEach(station => {
                if (station.lat && station.lon && !isNaN(station.lat) && !isNaN(station.lon)) {
                    const lat = parseFloat(station.lat);
                    const lng = parseFloat(station.lon);
                    
                    // Create station marker as a black circle
                    const stationMarker = L.circleMarker([lat, lng], {
                        radius: 4,
                        fillColor: '#000000',
                        color: '#000000',
                        weight: 1,
                        opacity: 1,
                        fillOpacity: 1,
                        zIndexOffset: 500
                    });
                    
                    // Create popup with station info
                    let popupContent = `
                        <div style="color: #000000; font-weight: bold;">
                            🚉 Amtrak Station
                        </div>
                        <b>Name:</b> ${station.name || 'Unknown'}<br>
                        <b>ID:</b> ${station.stationId}<br>`;
                    
                    if (station.city && station.state) {
                        popupContent += `<b>Location:</b> ${station.city}, ${station.state}<br>`;
                    }
                    
                    popupContent += `<b>Position:</b> ${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                    
                    stationMarker.bindPopup(popupContent);
                    
                    // Store marker
                    window.amtrakStationMarkers.set(station.stationId, stationMarker);
                    
                    // Add to map if Amtrak paths are shown
                    if (document.getElementById('show-amtrak-paths').checked) {
                        stationMarker.addTo(map);
                    }
                }
            });
            
        }

        // Function to load Amtrak stations from API (fallback)
        async function loadAmtrakStationsFromAPI() {
            try {
                if (!amtrakClient) {
                    amtrakClient = new AmtrakV3Client();
                }

                const stationsData = await amtrakClient.getAllStations();
                
                if (stationsData && Object.keys(stationsData).length > 0) {
                    const stationRecords = AmtrakV3Client.stationsDictToRecords(stationsData);
                    createAmtrakStationMarkers(stationRecords);
                }
                
                // Get feed health status
                await getAmtrakFeedHealth();
            } catch (error) {
                console.error('Error loading Amtrak stations from API:', error);
            }
        }
        
        // Function to get Amtrak feed health status
        async function getAmtrakFeedHealth() {
            try {
                if (!amtrakClient) {
                    amtrakClient = new AmtrakV3Client();
                }

                const healthData = await amtrakClient.getStaleStatus();

                
                // Display health info in console or could be shown on map
                if (healthData) {
                    const avgUpdate = healthData.avgLastUpdate ? new Date(healthData.avgLastUpdate).toLocaleString() : 'Unknown';
                    const activeTrains = healthData.activeTrains || 0;
                    const isStale = healthData.stale || false;
                    
    
                }
                
                return healthData;
            } catch (error) {
                console.error('Error getting Amtrak feed health:', error);
                return null;
            }
        }

        // Function to get specific Amtrak train information
        async function getAmtrakTrainInfo(trainIdOrNum) {
            try {
                if (!amtrakClient) {
                    amtrakClient = new AmtrakV3Client();
                }


                const trainData = await amtrakClient.getTrain(trainIdOrNum);
                
                if (trainData && Object.keys(trainData).length > 0) {
                    const trainRecords = AmtrakV3Client.trainsDictToRecords(trainData);
    
                    return trainRecords;
                } else {
    
                    return null;
                }
            } catch (error) {
                console.error(`Error getting info for train ${trainIdOrNum}:`, error);
                return null;
            }
        }

        // Function to poll specific Amtrak trains
        async function pollAmtrakTrains(trainIdsOrNums = null, intervalSec = 10.0, iterations = 6) {
            const snaps = [];
            
            for (let i = 0; i < iterations; i++) {
                try {
                    let tickData;
                    
                    if (trainIdsOrNums) {
                        // Poll specific trains
                        tickData = {};
                        for (const trainName of trainIdsOrNums) {
                            const d = await amtrakClient.getTrain(trainName) || {};
                            for (const [k, v] of Object.entries(d)) {
                                if (!tickData[k]) tickData[k] = [];
                                tickData[k].push(...(v || []));
                            }
                        }
                    } else {
                        // Poll all trains
                        tickData = await amtrakClient.getAllTrains() || {};
                    }

                    const rows = AmtrakV3Client.trainsDictToRecords(tickData);
                    snaps.push({
                        t_index: i,
                        ts: Date.now() / 1000,
                        rows: rows
                    });

                    const msg = `[${i+1}/${iterations}] fetched ${rows.length} train rows`;
    

                    if (i < iterations - 1) {
                        await new Promise(resolve => setTimeout(resolve, intervalSec * 1000));
                    }
                } catch (error) {
                    console.error(`Error in poll iteration ${i}:`, error);
                }
            }

            return snaps;
                }
        

        
        // Function to load Amtrak routes from local file
        async function loadAmtrakRoutes() {
            try {
                // Load routes from local file
                const response = await fetch('amtrak-routes-data.js');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const routesData = await response.json();
                
                if (routesData && routesData.routes && routesData.routes.length > 0) {
                    createAmtrakRouteLayersFromLocal(routesData.routes);
                    window.amtrakRoutesLoaded = true;
                } else {
                    throw new Error('No routes found in local file');
                }
            } catch (error) {
                console.error('Error loading Amtrak routes from local file:', error);
                // Fallback to API if local file fails
                await loadAmtrakRoutesFromAPI();
            }
        }
        
        // Function to load Amtrak routes from USDOT NTAD ArcGIS service
        async function loadAmtrakRoutesFromAPI() {
            try {
                // ArcGIS Feature Server URL for Amtrak routes
                const baseUrl = 'https://services.arcgis.com/xOi1kZaI0eWDREZv/ArcGIS/rest/services/NTAD_Amtrak_Routes/FeatureServer/0/query';
                
                const params = new URLSearchParams({
                    where: '1=1',
                    outFields: '*',
                    outSR: 4326,
                    f: 'geojson',
                    returnGeometry: 'true'
                });
                
                const response = await fetch(`${baseUrl}?${params.toString()}`, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const routesGeojson = await response.json();
                
                if (!routesGeojson.features || routesGeojson.features.length === 0) {
                    throw new Error('No Amtrak routes found');
                }
                
                // Create route layers and add to map
                createAmtrakRouteLayers(routesGeojson.features);
                window.amtrakRoutesLoaded = true;
                
            } catch (error) {
                console.error('Error loading Amtrak routes from USDOT NTAD:', error);
                // No fallback - just log the error
            }
        }
        
        // Function to create Amtrak route layers from local data
        function createAmtrakRouteLayersFromLocal(routes) {
            if (!window.amtrakRouteLayers) {
                window.amtrakRouteLayers = {};
            }
            
            // Ensure the layer group exists
            if (!window.amtrakRouteLayerGroup) {
                window.amtrakRouteLayerGroup = L.layerGroup().addTo(map);
            }
            
            routes.forEach(route => {
                if (route.coordinates && route.coordinates.length > 0) {
                    const routeName = route.name || 'Amtrak Route';
                    const color = getAmtrakRouteColor(routeName);
                    
                    // Convert coordinates to Leaflet format if needed
                    let latlngs;
                    if (route.geometryType === 'MultiLineString') {
                        latlngs = route.coordinates.map(line => 
                            line.map(coord => [coord[1], coord[0]]) // [lat, lng]
                        );
                    } else {
                        latlngs = route.coordinates.map(coord => [coord[1], coord[0]]); // [lat, lng]
                    }
                    
                    const polyline = L.polyline(latlngs, {
                        color: '#000000',
                        weight: 3,
                        opacity: 0.8
                    });
                    
                    polyline.routeName = routeName;
                    window.amtrakRouteLayers[routeName] = polyline;
                    
                    // Add popup with route info
                    const popupContent = `
                        <div style="color: #000000;">
                            <strong>${routeName}</strong><br>
                            ${route.properties ? `State: ${route.properties.STATE || 'N/A'}<br>` : ''}
                            ${route.properties ? `Length: ${route.properties.LENGTH_MI ? Math.round(route.properties.LENGTH_MI) + ' mi' : 'N/A'}<br>` : ''}
                            ${route.properties ? `Owner: ${route.properties.OWNER || 'N/A'}` : ''}
                        </div>
                    `;
                    polyline.bindPopup(popupContent);
                    
                    // Add to map
                    polyline.addTo(window.amtrakRouteLayerGroup);
                }
            });
        }
        
        // Function to create Amtrak route layers from GeoJSON features
        function createAmtrakRouteLayers(features) {
            if (!window.amtrakRouteLayers) {
                window.amtrakRouteLayers = {};
            }
            
            let processedCount = 0;
            let skippedCount = 0;
            
            features.forEach((feature, index) => {
                try {
                    const properties = feature.properties;
                    const geometry = feature.geometry;
                    

                    
                    // Extract route information
                    let routeName = 'Amtrak';
                    if (properties.ROUTE_NAME) {
                        routeName = properties.ROUTE_NAME;
                    } else if (properties.NAME) {
                        routeName = properties.NAME;
                    } else if (properties.ROUTE) {
                        routeName = properties.ROUTE;
                    }
                    
                    // Get route color
                    const routeColor = getAmtrakRouteColor(routeName);
                    
                    // Handle different geometry types
                    let routeLine = null;
                    
                    if (geometry && geometry.coordinates && geometry.coordinates.length > 0) {
                        if (geometry.type === 'LineString') {
                            // Convert coordinates from [longitude, latitude] to [latitude, longitude] for Leaflet
                            const latLngCoords = geometry.coordinates.map(coord => [coord[1], coord[0]]);
                            
                            routeLine = L.polyline(latLngCoords, {
                                color: '#000000',
                                weight: 3,
                                opacity: 0.8
                            });
                        } else if (geometry.type === 'MultiLineString') {
                            // Handle multi-line strings (routes with multiple segments)
                            const latLngCoords = geometry.coordinates.map(line => 
                                line.map(coord => [coord[1], coord[0]])
                            );
                            
                            routeLine = L.polyline(latLngCoords, {
                                color: '#000000',
                                weight: 3,
                                opacity: 0.8
                            });
                        }
                    }
                    
                    if (routeLine) {
                        // Create popup with route information
                        let popupContent = `
                            <div style="color: ${routeColor}; font-weight: bold;">
                                🚂 Amtrak Route
                            </div>
                            <b>Route:</b> ${routeName}<br>`;
                        
                        // Add additional properties if available
                        if (properties.STATE) {
                            popupContent += `<b>State:</b> ${properties.STATE}<br>`;
                        }
                        if (properties.LENGTH_MI) {
                            popupContent += `<b>Length:</b> ${properties.LENGTH_MI} miles<br>`;
                        }
                        if (properties.OWNER) {
                            popupContent += `<b>Owner:</b> ${properties.OWNER}<br>`;
                        }
                        
                        popupContent += `<b>Type:</b> Passenger Rail<br>
                            <b>Last Updated:</b> ${new Date().toLocaleDateString()}`;
                        
                        routeLine.bindPopup(popupContent);
                        
                        // Store route name with the layer
                        routeLine.routeName = routeName;
                        
                        // Store the layer
                        const layerKey = `amtrak_${index}`;
                        window.amtrakRouteLayers[layerKey] = routeLine;
                        
                        // Add to map if Amtrak paths are currently shown
                        if (document.getElementById('show-amtrak-paths').checked) {
                            routeLine.addTo(map);
                        }
                        
                        processedCount++;

                    } else {
                        skippedCount++;

                    }
                    
                } catch (error) {
                    console.error(`Error processing Amtrak route ${index}:`, error);
                    skippedCount++;
                }
            });
            
        }
        
        // Function to get color for Amtrak routes
        function getAmtrakRouteColor(routeName) {
            const routeNameLower = routeName.toLowerCase();
            
            // Match specific route names to colors
            if (routeNameLower.includes('northeast corridor') || routeNameLower.includes('nec')) {
                return lineColors['Northeast Corridor'] || '#DC2626';
            } else if (routeNameLower.includes('acela')) {
                return lineColors['Acela'] || '#7C2D12';
            } else if (routeNameLower.includes('vermouter') || routeNameLower.includes('vermont')) {
                return lineColors['Vermonter'] || '#059669';
            } else if (routeNameLower.includes('downeaster') || routeNameLower.includes('maine')) {
                return lineColors['Downeaster'] || '#7C3AED';
            } else if (routeNameLower.includes('lake shore') || routeNameLower.includes('chicago')) {
                return lineColors['Lake Shore Limited'] || '#EA580C';
            } else if (routeNameLower.includes('empire') || routeNameLower.includes('new york')) {
                return lineColors['Empire Service'] || '#BE185D';
            } else {
                // Default Amtrak blue for other routes
                return lineColors['Amtrak'] || '#1E3A8A';
            }
        }
        

        

        
        // Function to update train markers on the map
        function updateTrainMarkers(trains) {
            // Store current popup states before clearing markers
            const currentPopups = new Map();
            trainMarkers.forEach((marker, trainId) => {
                if (marker && marker.isPopupOpen && marker.isPopupOpen()) {
                    currentPopups.set(trainId, marker.getPopup().getContent());
                }
            });
            
            // Clear old train markers
            trainMarkers.forEach((marker, trainId) => {
                if (marker && marker.remove) {
                    marker.remove();
                }
            });
            trainMarkers.clear();
            
            // Create new train markers
                            trains.forEach(train => {
                    if (train.attributes && train.attributes.latitude && train.attributes.longitude) {
                        const trainId = train.id;
                        const lat = train.attributes.latitude;
                        const lng = train.attributes.longitude;
                        const heading = train.attributes.heading || 0;
                        const speed = train.attributes.speed;
                        const currentStatus = train.attributes.current_status;
                        const routeId = train.relationships?.route?.data?.id;
                        

                        

                    
                    // Get route name and color with better matching
                    let routeName = 'Unknown Route';
                    let color = '#666';
                    
                    if (routeId && mbtaStopsData) {

                        
                        // Better route matching logic
                        if (mbtaStopsData) {
                            Object.keys(mbtaStopsData).forEach(name => {
                                // Check for exact matches first
                                if (name === routeId || 
                                    name.replace(/\s+/g, '') === routeId ||
                                    name.replace(/\s+/g, '') === routeId.replace(/\s+/g, '') ||
                                    routeId.includes(name.replace(/\s+/g, '')) ||
                                    name.includes(routeId.replace(/\s+/g, ''))) {
                                    routeName = name;
                                    color = lineColors[name] || '#666';
                                }
                            });
                            
                            // If no match found, try partial matching for commuter rail
                            if (routeName === 'Unknown Route' && routeId.startsWith('CR-')) {
                                // First try to match against mbtaStopsData
                                Object.keys(mbtaStopsData).forEach(name => {
                                    if (name.includes('Line') && routeId.includes(name.split(' ')[0])) {
                                        routeName = name;
                                        color = lineColors[name] || '#800080'; // Default purple for commuter rail
                                    }
                                });
                                
                                // If still no match, try to match against commuterLines array
                                if (routeName === 'Unknown Route') {
                                    const routeSuffix = routeId.substring(3); // Remove "CR-" prefix
                                    commuterLines.forEach(lineName => {
                                        if (lineName.toLowerCase().includes(routeSuffix.toLowerCase()) || 
                                            routeSuffix.toLowerCase().includes(lineName.split(' ')[0].toLowerCase())) {
                                            routeName = lineName;
                                            color = lineColors[lineName] || '#800080'; // Default purple for commuter rail
                                        }
                                    });
                                }
                            }
                            
                            // If still no match, try to identify Green Line routes specifically
                            if (routeName === 'Unknown Route' && (routeId.includes('Green') || routeId.includes('GL'))) {
                                // Try to match specific Green Line branch
                                if (routeId.includes('Green-B') || routeId.includes('GL-B')) {
                                    routeName = 'Green Line B';
                                } else if (routeId.includes('Green-C') || routeId.includes('GL-C')) {
                                    routeName = 'Green Line C';
                                } else if (routeId.includes('Green-D') || routeId.includes('GL-D')) {
                                    routeName = 'Green Line D';
                                } else if (routeId.includes('Green-E') || routeId.includes('GL-E')) {
                                    routeName = 'Green Line E';
                                } else {
                                    routeName = 'Green Line';
                                }
                                color = lineColors['Green Line B'] || '#00843D';
                            }
                        }
                    }
                    
                    // Create train marker with custom line-specific icons
                    let trainIcon;
                    
                    if (routeName.includes('Red Line') || routeName.includes('Mattapan')) {
                        trainIcon = L.icon({
                            iconUrl: 'icons/readlinecirc.png',
                            iconSize: [24, 24],
                            iconAnchor: [12, 12]
                        });
                    } else if (routeName.includes('Blue Line')) {
                        trainIcon = L.icon({
                            iconUrl: 'icons/bluelinecirc.png',
                            iconSize: [24, 24],
                            iconAnchor: [12, 12]
                        });
                    } else if (routeName.includes('Green Line') || routeName.includes('Green-')) {
                        trainIcon = L.icon({
                            iconUrl: 'icons/greenlinecirc.png',
                            iconSize: [24, 24],
                            iconAnchor: [12, 12]
                        });
                    } else if (routeName.includes('Orange Line')) {
                        trainIcon = L.icon({
                            iconUrl: 'icons/orangelinecirc.png',
                            iconSize: [24, 24],
                            iconAnchor: [12, 12]
                        });
                    } else {
                        // Use commuter rail icon for all other routes (CapeFlyer, Fairmount, etc.)
                        trainIcon = L.icon({
                            iconUrl: 'icons/commuterrailcirc.png',
                            iconSize: [24, 24],
                            iconAnchor: [12, 12]
                        });
                    }
                    
                    const trainMarker = L.marker([lat, lng], {
                        icon: trainIcon,
                        zIndexOffset: 200
                    });
                    
                    // Get direction information (inbound/outbound)
                    const direction = train.attributes.direction_id === 0 ? 'Inbound' : 'Outbound';
                    
                    // Create popup with train info
                    let popupContent = `
                        <div style="color: ${color}; font-weight: bold;">
                            <img src="${trainIcon.options.iconUrl}" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 8px;">
                            Live Train
                        </div>
                        <b>Route:</b> ${routeName === 'Unknown Route' ? (routeId.startsWith('CR-') ? routeId.substring(3) + ' Line' : routeId) : routeName}<br>`;
                    
                    // Only show speed if it's a valid number
                    if (speed !== null && speed !== undefined && speed !== 'none' && !isNaN(speed) && speed > 0) {
                        popupContent += `<b>Speed:</b> ${Math.round(speed)} mph<br>`;
                    }
                    
                    // Add current status if available
                    if (currentStatus) {
                        let statusText = currentStatus;
                        if (currentStatus === 'STOPPED_AT') {
                            statusText = 'Stopped';
                        } else if (currentStatus === 'IN_TRANSIT_TO') {
                            statusText = 'In Transit';
                        } else if (currentStatus === 'INCOMING_AT') {
                            statusText = 'Incoming';
                        }
                        popupContent += `<b>Status:</b> ${statusText}<br>`;
                    }
                    
                    popupContent += `
                        <b>Train ID:</b> ${trainId}<br>`;
                    
                    // Show terminus for specific lines, direction ID for others
                    if (routeName.includes('Red Line')) {
                        if (train.attributes.direction_id === 1) {
                            popupContent += `<b>Terminus:</b> Alewife<br>`;
                        } else {
                            popupContent += `<b>Terminus:</b> Ashmont/Braintree<br>`;
                        }
                    } else if (routeName.includes('Orange Line')) {
                        if (train.attributes.direction_id === 1) {
                            popupContent += `<b>Terminus:</b> Oak Grove<br>`;
                        } else {
                            popupContent += `<b>Terminus:</b> Forest Hills<br>`;
                        }
                    } else if (routeName.includes('Blue Line')) {
                        if (train.attributes.direction_id === 1) {
                            popupContent += `<b>Terminus:</b> Wonderland<br>`;
                        } else {
                            popupContent += `<b>Terminus:</b> Bowdoin<br>`;
                        }
                    } else if (routeName.includes('Green Line B')) {
                        if (train.attributes.direction_id === 1) {
                            popupContent += `<b>Terminus:</b> Government Center<br>`;
                        } else {
                            popupContent += `<b>Terminus:</b> Boston College<br>`;
                        }
                    } else if (routeName.includes('Green Line C')) {
                        if (train.attributes.direction_id === 1) {
                            popupContent += `<b>Terminus:</b> Government Center<br>`;
                        } else {
                            popupContent += `<b>Terminus:</b> Cleveland Circle<br>`;
                        }
                    } else if (routeName.includes('Green Line D')) {
                        if (train.attributes.direction_id === 1) {
                            popupContent += `<b>Terminus:</b> Union Square<br>`;
                        } else {
                            popupContent += `<b>Terminus:</b> Riverside<br>`;
                        }
                    } else if (routeName.includes('Green Line E')) {
                        if (train.attributes.direction_id === 1) {
                            popupContent += `<b>Terminus:</b> Medford/Tufts<br>`;
                        } else {
                            popupContent += `<b>Terminus:</b> Heath Street<br>`;
                        }
                    } else {
                        // Handle commuter rail and other routes with terminus logic
                        if (routeId && routeId.startsWith('CR-')) {
                            const lineName = routeId.substring(3); // Remove "CR-" prefix
                            const northStationLines = ['Fitchburg', 'Lowell', 'Rockport', 'Newburyport', 'Haverhill'];
                            
                            if (train.attributes.direction_id === 0) {
                                // Outbound: show the line's terminus
                                popupContent += `<b>Terminus:</b> ${lineName}<br>`;
                            } else {
                                // Inbound: show Boston station
                                const terminus = northStationLines.includes(lineName) ? 'North Station' : 'South Station';
                                popupContent += `<b>Terminus:</b> ${terminus}<br>`;
                            }
                        } else {
                            popupContent += `<b>Direction ID:</b> ${train.attributes.direction_id}<br>`;
                        }
                    }
                    
                    popupContent += `
                        <b>Position:</b> ${lat.toFixed(6)}, ${lng.toFixed(6)}<br>
                        <b>Last Update:</b> ${new Date().toLocaleTimeString()}
                    `;
                    
                    trainMarker.bindPopup(popupContent);
                    
                    // Store route name with marker for filtering
                    trainMarker.routeName = routeName;
                    
                    // Add to map and store reference (only if the category is checked)
                    let shouldShow = false;
                    
                    // Check if this train should be shown based on live tracking checkbox states
                    if (routeName.includes('Line') && document.getElementById('show-subway-live').checked) {
                        shouldShow = true;
                    } else if (commuterLines.includes(routeName) && document.getElementById('show-commuter-live').checked) {
                        shouldShow = true;
                    } else if (seasonalLines.includes(routeName) && document.getElementById('show-seasonal-live').checked) {
                        shouldShow = true;
                    }
                    
                    if (shouldShow) {
                        trainMarker.addTo(map);
                    }
                    
                    trainMarkers.set(trainId, trainMarker);
                    
                    // Restore popup if it was open before
                    if (currentPopups.has(trainId)) {
                        trainMarker.openPopup();
                    }
                }
            });
            

        }
        
        // Function to update bus markers on the map
        function updateBusMarkers(buses) {
            // Store current popup states before clearing markers
            const currentPopups = new Map();
            busMarkers.forEach((marker, busId) => {
                if (marker && marker.isPopupOpen && marker.isPopupOpen()) {
                    currentPopups.set(busId, marker.getPopup().getContent());
                }
            });
            
            // Clear old bus markers
            busMarkers.forEach((marker, busId) => {
                if (marker && marker.remove) {
                    marker.remove();
                }
            });
            busMarkers.clear();
            
            // Create new bus markers
            buses.forEach(bus => {
                if (bus.attributes && bus.attributes.latitude && bus.attributes.longitude) {
                    const busId = bus.id;
                    const lat = bus.attributes.latitude;
                    const lng = bus.attributes.longitude;
                    const heading = bus.attributes.heading || 0;
                    const speed = bus.attributes.speed;
                    const currentStatus = bus.attributes.current_status;
                    const routeId = bus.relationships?.route?.data?.id;
                    

                    
                    // Get route name and color
                    let routeName = 'Unknown Bus Route';
                    let color = '#FFD700'; // Default bus gold
                    

                    
                    if (routeId) {
                        // Always show the route ID from the API, don't try to match with our data
                        routeName = `Bus Route ${routeId}`;
                        color = lineColors[routeId] || '#FFD700';
                    }
                    
                    // Create bus marker with bus icon
                    const busIcon = L.icon({
                        iconUrl: 'icons/buscirc.png',
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    });
                    
                    const busMarker = L.marker([lat, lng], {
                        icon: busIcon,
                        zIndexOffset: 250
                    });
                    
                    // Get direction information (inbound/outbound)
                    const direction = bus.attributes.direction_id === 0 ? 'Inbound' : 'Outbound';
                    
                    // Create popup with bus info
                    let popupContent = `
                        <div style="color: ${color}; font-weight: bold;">
                            <img src="${busIcon.options.iconUrl}" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 8px;">
                            Live Bus
                        </div>
                        <b>Route:</b> ${routeName}<br>
                        <b>Direction:</b> ${direction}<br>`;
                    
                    // Only show speed if it's a valid number
                    if (speed !== null && speed !== undefined && speed !== 'none' && !isNaN(speed) && speed > 0) {
                        popupContent += `<b>Speed:</b> ${Math.round(speed)} mph<br>`;
                    }
                    
                    // Show status if available
                    if (currentStatus && currentStatus !== 'none') {
                        popupContent += `<b>Status:</b> ${currentStatus}<br>`;
                    }
                    
                    // Show heading if available
                    if (heading !== null && heading !== undefined && heading !== 'none' && !isNaN(heading)) {
                        popupContent += `<b>Heading:</b> ${Math.round(heading)}°<br>`;
                    }
                    
                    popupContent += `
                        <b>Position:</b> ${lat.toFixed(6)}, ${lng.toFixed(6)}<br>
                        <b>Last Update:</b> ${new Date().toLocaleTimeString()}
                    `;
                    
                    busMarker.bindPopup(popupContent);
                    
                    // Store route name with marker for filtering
                    busMarker.routeName = routeName;
                    
                    // Add to map and store reference (only if bus live tracking checkbox is checked)
                    if (document.getElementById('show-bus-live').checked) {
                        busMarker.addTo(map);
                    }
                    
                    busMarkers.set(busId, busMarker);
                    
                    // Restore popup if it was open before
                    if (currentPopups.has(busId)) {
                        busMarker.openPopup();
                    }
                }
            });
        }
        
        // Function to update ferry markers on the map
        function updateFerryMarkers(ferries) {
            // Clear old ferry markers
            ferryMarkers.forEach((marker, ferryId) => {
                if (marker && marker.remove) {
                    marker.remove();
                }
            });
            ferryMarkers.clear();
            
            // Create new ferry markers
            ferries.forEach(ferry => {
                if (ferry.attributes && ferry.attributes.latitude && ferry.attributes.longitude) {
                    const ferryId = ferry.id;
                    const lat = ferry.attributes.latitude;
                    const lng = ferry.attributes.longitude;
                    const heading = ferry.attributes.heading || 0;
                    const speed = ferry.attributes.speed;
                    const currentStatus = ferry.attributes.current_status;
                    const routeId = ferry.relationships?.route?.data?.id;
                    
                    // Get route name and color
                    let routeName = 'Unknown Ferry Route';
                    let color = '#008EAA'; // Default ferry blue
                    
                    if (routeId && mbtaFerryData) {
                        if (mbtaFerryData[routeId]) {
                            routeName = mbtaFerryData[routeId][0]?.name || routeId;
                            color = lineColors[routeId] || '#008EAA';
                        }
                    }
                    
                    // Create ferry marker with boat icon
                    const ferryIcon = L.icon({
                        iconUrl: 'icons/commuterrailcirc.png', // Use commuter rail icon for now
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    });
                    
                    const ferryMarker = L.marker([lat, lng], {
                        icon: ferryIcon,
                        zIndexOffset: 300
                    });
                    
                    // Create popup with ferry info
                    let popupContent = `
                        <div style="color: ${color}; font-weight: bold;">
                            <img src="${ferryIcon.options.iconUrl}" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 8px;">
                            Live Ferry
                        </div>
                        <b>Route:</b> ${routeName}<br>`;
                    
                    // Only show speed if it's a valid number
                    if (speed !== null && speed !== undefined && speed !== 'none' && !isNaN(speed) && speed > 0) {
                        popupContent += `<b>Speed:</b> ${Math.round(speed)} mph<br>`;
                    }
                    
                    // Add current status if available
                    if (currentStatus) {
                        let statusText = currentStatus;
                        if (currentStatus === 'STOPPED_AT') {
                            statusText = 'Stopped';
                        } else if (currentStatus === 'IN_TRANSIT_TO') {
                            statusText = 'In Transit';
                        } else if (currentStatus === 'INCOMING_AT') {
                            statusText = 'Incoming';
                        }
                        popupContent += `<b>Status:</b> ${statusText}<br>`;
                    }
                    
                    popupContent += `
                        <b>Ferry ID:</b> ${ferryId}<br>
                        <b>Position:</b> ${lat.toFixed(6)}, ${lng.toFixed(6)}<br>
                        <b>Last Update:</b> ${new Date().toLocaleTimeString()}
                    `;
                    
                    ferryMarker.bindPopup(popupContent);
                    
                    // Add to map and store reference
                    ferryMarker.addTo(map);
                    ferryMarkers.set(ferryId, ferryMarker);
                }
            });
        }
        
        // Start live tracking
        function startLiveTracking() {
            if (trackingInterval) {
                clearInterval(trackingInterval);
            }
            if (amtrakTrackingInterval) {
                clearInterval(amtrakTrackingInterval);
            }
            if (busTrackingInterval) {
                clearInterval(busTrackingInterval);
            }
            
            // Initial fetch
            fetchLiveTrains();
            fetchLiveAmtrakTrains();
            fetchLiveBuses();
            
            // Set up interval for updates
            trackingInterval = setInterval(fetchLiveTrains, 5000); // Update every 5 seconds
            amtrakTrackingInterval = setInterval(fetchLiveAmtrakTrains, 10000); // Update every 10 seconds for Amtrak
            busTrackingInterval = setInterval(fetchLiveBuses, 5000); // Update every 5 seconds for buses
            
            console.log('Live tracking started');
        }
        

        
        // Stop live tracking for a specific category
        function stopLiveTrackingForCategory(category) {
            // Clear markers for the specific category
            if (category === 'subway') {
                // Clear subway train markers
                trainMarkers.forEach((marker, trainId) => {
                    if (marker && marker.routeName && marker.routeName.includes('Line')) {
                        if (marker.remove) marker.remove();
                    }
                });
            } else if (category === 'commuter') {
                // Clear commuter rail train markers
                trainMarkers.forEach((marker, trainId) => {
                    if (marker && marker.routeName && commuterLines.includes(marker.routeName)) {
                        if (marker.remove) marker.remove();
                    }
                });
            } else if (category === 'amtrak') {
                // Clear Amtrak train markers
                amtrakMarkers.forEach((marker, trainId) => {
                    if (marker && marker.remove) marker.remove();
                });
            } else if (category === 'seasonal') {
                // Clear seasonal rail train markers
                trainMarkers.forEach((marker, trainId) => {
                    if (marker && marker.routeName && seasonalLines.includes(marker.routeName)) {
                        if (marker.remove) marker.remove();
                    }
                });
            } else if (category === 'bus') {
                // Clear bus markers
                busMarkers.forEach((marker, busId) => {
                    if (marker && marker.remove) marker.remove();
                });
            }
            
            // Check if any categories are still checked for live tracking
            const hasSubway = document.getElementById('show-subway-live').checked;
            const hasCommuter = document.getElementById('show-commuter-live').checked;
            const hasSeasonal = document.getElementById('show-seasonal-live').checked;
            const hasBus = document.getElementById('show-bus-live').checked;
            const hasFerry = document.getElementById('show-ferry-live').checked;
            const hasAmtrak = document.getElementById('show-amtrak-live').checked;
            
            // If no categories are checked, stop all live tracking
            if (!hasSubway && !hasCommuter && !hasSeasonal && !hasBus && !hasFerry && !hasAmtrak) {
                stopLiveTracking();
            }
        }
        
        // Stop live tracking
        function stopLiveTracking() {
            if (trackingInterval) {
                clearInterval(trackingInterval);
                trackingInterval = null;
            }
            if (amtrakTrackingInterval) {
                clearInterval(amtrakTrackingInterval);
                amtrakTrackingInterval = null;
            }
            if (busTrackingInterval) {
                clearInterval(busTrackingInterval);
                busTrackingInterval = null;
            }
            
            // Clear all train markers
            trainMarkers.forEach((marker, trainId) => {
                if (marker && marker.remove) {
                    marker.remove();
                }
            });
            trainMarkers.clear();
            
            // Clear all bus markers
            busMarkers.forEach((marker, busId) => {
                if (marker && marker.remove) {
                    marker.remove();
                }
            });
            busMarkers.clear();
            
            // Clear all Amtrak markers (if any are added in the future)
            amtrakMarkers.forEach((marker, amtrakId) => {
                if (marker && marker.remove) {
                    marker.remove();
                }
            });
            amtrakMarkers.clear();
        }
        

        

        

        
        // Initially show layers based on checkbox states
        if (mbtaStopsData && typeof mbtaStopsData === 'object') {
            Object.keys(mbtaStopsData).forEach(lineName => {
                if (layers[lineName]) {
                    // Check if this line should be shown based on checkbox states
                    let shouldShow = false;
                    
                    if (lineName.includes('Line') && document.getElementById('show-subway-paths').checked) {
                        shouldShow = true;
                    } else if (commuterLines.includes(lineName) && document.getElementById('show-commuter-paths').checked) {
                        shouldShow = true;
                    } else if (seasonalLines.includes(lineName) && document.getElementById('show-seasonal-paths').checked) {
                        shouldShow = true;
                    }
                    
                    if (shouldShow) {
                        map.addLayer(layers[lineName]);
                    }
                }
            });
        }
        
        // Don't show bus layers by default since checkbox is unchecked
        // Bus layers will be shown when checkbox is checked
        if (mbtaBusData && typeof mbtaBusData === 'object') {
            // Store bus layers but don't add them to map yet
            Object.keys(mbtaBusData).forEach(lineName => {
                if (layers[lineName]) {
                    // Don't add to map - wait for checkbox to be checked
                }
            });
        }
        
        if (mbtaFerryData && typeof mbtaFerryData === 'object') {
            Object.keys(mbtaFerryData).forEach(lineName => {
                if (layers[lineName]) {
                    if (document.getElementById('show-ferry-paths').checked) {
                        map.addLayer(layers[lineName]);
                    }
                }
            });
        }
        
        // Load Amtrak data if checkbox is checked by default
        if (document.getElementById('show-amtrak-paths').checked) {
            setTimeout(() => {
                loadAmtrakRoutes();
                loadAmtrakStations();
            }, 1000);
        }
        
        // Start tracking after a short delay to let the map load
        setTimeout(() => {
            startLiveTracking();
        }, 2000);
        
    </script>
</body>
</html>
